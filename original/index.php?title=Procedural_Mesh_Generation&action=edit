<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" /><title>View source for Procedural Mesh Generation - Epic Wiki</title>
<meta name="generator" content="MediaWiki 1.22.2" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="Epic Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.unrealengine.com/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Epic Wiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=epic&amp;*" />
<link rel="stylesheet" href="/extensions/EpicVideoSystem/CSS/VideoSystem.css" />
<link rel="stylesheet" href="/skins/epic/resources/screen.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/epic.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/prettify.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/jquery.qtip.css?303" media="screen" /><meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=epic&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: my_wiki:resourceloader:filter:minify-css:7:07b6a8ccf3fd62e770f192d0a6f8e123 */</style>

<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=epic&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Procedural_Mesh_Generation","wgTitle":"Procedural Mesh Generation","wgCurRevisionId":17873,"wgRevisionId":0,"wgArticleId":914,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Procedural_Mesh_Generation","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"templateEditor":false,"templates":false,"preview":true,"previewDialog":false,"publish":true,"toc":false}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"epic","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: my_wiki:resourceloader:filter:minify-js:7:2197af7670c41256853f340e275ede1b */
}</script>
<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=skins.epic.extras.js%7Cskins.epic.fancybox.js%7Cskins.epic.js%7Cskins.epic.qtip.js%7Cskins.epic.slimscroll.js&amp;only=scripts&amp;skin=epic&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/epic/csshover.min.htc")}</style><![endif]--><script type="text/javascript">
var experimentID = false;
var cxApi = null;
var variation = 0;
var fancyTitle = "";
var CE_SNAPSHOT_NAME = document.getElementsByTagName("title")[0].innerHTML;
$(document).ready(function(){
	if(experimentID != false)
	{
		$(head).append('<script src="//www.google-analytics.com/cx/api.js?experiment=' + experimentID + '" />' + '</scr' + 'ipt>');
		HandleExperiment();
	}
	else
	{
		CE_SNAPSHOT_NAME = (fancyTitle != "" ? fancyTitle : document.getElementsByTagName("title")[0].innerHTML);
		setTimeout(function () {
			var a = document.createElement("script");
			var b = document.getElementsByTagName("script")[0];
			a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
			a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
		}, 1);	
	}
});
function HandleExperiment()
{
	CE_SNAPSHOT_NAME = (fancyTitle != "" ? fancyTitle : document.getElementsByTagName("title")[0].innerHTML);
	if(cxApi != null)
	{
		variation = cxApi.chooseVariation();
		cxApi.setChosenVariation(variation, experimentID);
		if(variation != cxApi.ORIGINAL_VARIATION && variation != cxApi.NO_CHOSEN_VARIATION && variation != cxApi.NOT_PARTICIPATING)
		{
			//var URL = document.location.href + (document.location.search != '' ? '&var=' : '?var=') + variation;
			ga('send', 'event', 'A/B', 'ID: ' + experimentID, 'Variation: ' + variation, {'nonInteraction': 1});
			//document.location.href = URL; 
			CE_SNAPSHOT_NAME = document.getElementsByTagName("title")[0].innerHTML + ' (variation ' + variation + ')';
			var test = "";
		}
		else
		{
			ga('send', 'event', 'A/B', 'ID: ' + experimentID, 'Variation: ' + variation, {'nonInteraction': 1});
		}
		ToggleExperimentContent(variation);
		setTimeout(function () {
			var a = document.createElement("script");
			var b = document.getElementsByTagName("script")[0];
			a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
			a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
		}, 1);
	}
	else
	{
		setTimeout("HandleExperiment()", 500);
	}
}

function ToggleExperimentContent(variation)
{
	$('.AB').hide();
	$('#variation_' + variation).show();
}
</script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Procedural_Mesh_Generation skin-epic action-edit vector-animateLayout">
		<!--<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>-->
		<!-- Google Tag Manager -->
		<noscript>
			<iframe src="//www.googletagmanager.com/ns.html?id=GTM-KWRD6D"
					height="0" width="0" style="display:none;visibility:hidden"></iframe>
		</noscript>
		<script>
		(function (w, d, s, l, i) {
		w[l] = w[l] || []; w[l].push({
		'gtm.start':
		new Date().getTime(), event: 'gtm.js'
		}); var f = d.getElementsByTagName(s)[0],
		j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
		'//www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
		})(window, document, 'script', 'dataLayer', 'GTM-KWRD6D');</script>
		<!-- End Google Tag Manager -->
		<div id="webThree">
		<div id="head">
		









<!DOCTYPE html>
<html>
    <head>
        
            <link rel="stylesheet" href="https://cdn1.unrealengine.com/2914259/unifiedHeader-3d2c9ef25bcd93abc24a45ff7ec4282f.css">
        
    </head>

    <body>
        <input type="hidden" id="updateenable" value="true">

        
            

<!DOCTYPE html>
<html>
    <head>
    	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
        
            <link rel="stylesheet" href="https://cdn1.unrealengine.com/2914259/webpack/epicGamesHeader.epic-games-nav-8bdd68f01817afb9b978f4481fcc2994.css"/>
        
    </head>
    <body>
        <script type="text/javascript">
            //required so the config object is not utf-8 encoded
            
                (function() {
                    var config = (function(){ return {"hideSearch":false,"_contentType":426,"links":[{"title":"About","useCustomCallback":false,"kids":[{"title":"Overview","href":"https://www.unrealengine.com/what-is-unreal-engine-4"},{"title":"Features","href":"https://www.unrealengine.com/unreal-engine-4"},{"title":"Virtual Reality","href":"https://www.unrealengine.com/vr-page"},{"title":"Showcase","href":"https://www.unrealengine.com/showcase"},{"title":"What's New","href":"https://www.unrealengine.com/410-release-notes-overview"},{"title":"FAQ / EULA","href":"https://www.unrealengine.com/faq"},{"title":"Previous Versions","href":"https://www.unrealengine.com/previous-versions"},{"title":"Enterprise","href":"https://www.unrealengine.com/enterprise"}],"key":"about"},{"title":"Learn","useCustomCallback":false,"collapseTarget":"More","kids":[{"title":"Documentation","useCustomCallback":false,"href":"https://docs.unrealengine.com/"},{"title":"Video Tutorials","useCustomCallback":false,"href":"https://wiki.unrealengine.com/Videos "},{"title":"Wiki","useCustomCallback":false,"href":"https://wiki.unrealengine.com/Main_Page"}],"key":"learn"},{"title":"Community","useCustomCallback":false,"collapseTarget":"More","kids":[{"title":"Blog","href":"https://www.unrealengine.com/blog"},{"title":"Forums","useCustomCallback":false,"href":"https://forums.unrealengine.com/"},{"title":"AnswerHub","useCustomCallback":false,"href":"https://answers.unrealengine.com/"},{"title":"Roadmap","useCustomCallback":false,"href":"https://trello.com/b/gHooNW9I/ue4-roadmap"},{"title":"Unreal Dev Grants","href":"https://www.unrealengine.com/unrealdevgrants"},{"title":"Unreal Tournament","useCustomCallback":false,"href":"http://www.unrealtournament.com/blog/"}],"key":"community"},{"title":"Marketplace","useCustomCallback":false,"collapseTarget":"More","kids":[{"title":" Browse","href":"https://www.unrealengine.com/marketplace"},{"title":"Business Terms","useCustomCallback":false,"href":"https://publish.unrealengine.com/faq"},{"title":"Submission Guidelines","useCustomCallback":false,"href":"https://publish.unrealengine.com/submission-guidelines"},{"title":"Submit Your Content","useCustomCallback":false,"href":"https://publish.unrealengine.com/welcome"},{"title":"Marketplace Forums","useCustomCallback":false,"href":"https://forums.unrealengine.com/forumdisplay.php?56-Marketplace"}],"key":"marketplace"},{"title":"Academia","useCustomCallback":false,"collapseTarget":"More","kids":[{"title":"Education Program","href":"https://www.unrealengine.com/education"},{"title":"Academic Partners","href":"https://www.unrealengine.com/academic-partners"}],"key":"academia"}],"epicPropertyName":"unreal_engine","properties":[{"egSkip":false,"egDisabled":false}],"hideLocale":true,"messages":{"sign_in":"Sign In","search":"Search","locale":"Locale","sign_out":"Sign Out","default_username":"Account"},"logoLink":{"key":"logo","href":"https://www.unrealengine.com/blog"},"hideCallToAction":false,"accountLinks":{"signOutLink":{"useCustomCallback":true,"key":"signout"},"signInLinks":[{"title":"Sign In","href":"https://www.unrealengine.com/login","key":"signin"}],"dropdownLinks":[{"title":"Personal","href":"https://www.unrealengine.com/dashboard","key":"personal"},{"title":"Seller","useCustomCallback":false,"href":"https://publish.unrealengine.com/"}]},"downloadLink":{"title":"Get Unreal","useCustomCallback":true},"callToAction":{"title":"Get Unreal","useCustomCallback":true},"hideSignIn":true,"overrideParams":{"hideLocale":true,"useServerUrl":true,"hideSignIn":true},"locale":"en-US","serverUrl":"https://www.unrealengine.com"}; })();
                    if (typeof window._epicGamesNav === 'undefined') {
                        window._epicGamesNav = config;
                    } else {
                        for (var key in config) {
                            if (typeof key === 'string') {
                                if (!window._epicGamesNav[key] && config[key] !== null) {
                                    window._epicGamesNav[key] = config[key];
                                }
                            }
                        }
                    }

                    /**
                     * For a documented example of what the config json object looks like:
                     *   /frontend/app/scripts/utils/epicGamesNavObserver.js
                     */
                })();
            
        </script>

        <div id="epicGamesNavigation" data-external="false"></div>

        
            <script src="https://cdn1.unrealengine.com/2914259/webpack/epicGamesHeader.epic-games-nav-e2bdecdb85442f990ed9317c5bf5965c.js" type="text/javascript" ></script>
        
    </body>
</html>
        

        

        
            <link rel="stylesheet" href="https://cdn1.unrealengine.com/2914259/webpack/epicGamesHeader.epic-games-nav-8bdd68f01817afb9b978f4481fcc2994.css"/>
        

        <script src="https://cdn1.unrealengine.com/2914259/epicGamesHeaderBundle-326e37f675279686aeb27f816e260031.js" defer></script>

        <div id="header" data-path="" data-sitepath="https://www.unrealengine.com">
            <input type="hidden" id="isUnified" value="1" />
            <input type="hidden" id="current_locale" value="en-US"/>
            <input type="hidden" id="header-host" value="https://www.unrealengine.com" />
            <input type="hidden" id="current_country" value="US"/>
        </div>
    </body>
</html>




		</div>
		<div id="pagedefault">		
                    <div id="pagenav">
                        <div>
                            <!-- Start of Other language links -->
                            <!-- End of Other language links -->
                            <div class="homelink_container">
                                <a href="https://wiki.unrealengine.com" title="UE4 Wiki Home" class="homelink">HOME</a>
                            </div>
                        </div>
                        <div style="clear:both;">
                        </div>
                    </div>	
		<div id="mw-navigation" style="max-width:972px;margin:1em auto 0 auto;">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="jumplink" onclick="$('#sidebar').toggle();">
					Navigation
				</div>
				<div id="sidebar">
					<!-- Start of jump page links -->
					<div class="largetitle">
						Quick Links
					</div>
					<div class="arrowlist">
						<!-- End of jump page links -->
						<!-- Start of related page links -->
						<!-- End of related page links -->								
						<div id="mw-panel">
							<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Community' aria-labelledby='p-Community-label'>
	<h3 id='p-Community-label'>Community</h3>
	<div class="body">
		<ul>
			<li id="n-UE4-Games"><a href="/Category:Games">UE4 Games</a></li>
			<li id="n-Dev-Blogs"><a href="/Developer_Blogs">Dev Blogs</a></li>
			<li id="n-Dev-Livestreams"><a href="/Developer_Livestreams">Dev Livestreams</a></li>
			<li id="n-Code-Sharing-Hub"><a href="/GitHub_Sharing_Hub">Code Sharing Hub</a></li>
			<li id="n-UE-User-Groups"><a href="/User_Group_Map">UE User Groups</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Learning_Resources' aria-labelledby='p-Learning_Resources-label'>
	<h3 id='p-Learning_Resources-label'>Learning Resources</h3>
	<div class="body">
		<ul>
			<li id="n-Tutorials"><a href="/Category:Tutorials">Tutorials</a></li>
			<li id="n-Example-Projects"><a href="/Category:Example_Projects">Example Projects</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Software_and_Tools' aria-labelledby='p-Software_and_Tools-label'>
	<h3 id='p-Software_and_Tools-label'>Software and Tools</h3>
	<div class="body">
		<ul>
			<li id="n-Plug-ins"><a href="/Category:Plug-ins">Plug-ins</a></li>
			<li id="n-Art:-3D"><a href="/3D_Art_Resources">Art: 3D</a></li>
			<li id="n-Art:-2D"><a href="/2D_Art_Resources">Art: 2D</a></li>
			<li id="n-Audio"><a href="/Audio_Resources">Audio</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Modding' aria-labelledby='p-Modding-label'>
	<h3 id='p-Modding-label'>Modding</h3>
	<div class="body">
		<ul>
			<li id="n-Modding-Resources"><a href="/Category:Modding_Resources">Modding Resources</a></li>
			<li id="n-Moddable-Games"><a href="/Category:Moddable_Games">Moddable Games</a></li>
			<li id="n-Unreal-Tournament"><a href="/Category:Unreal_Tournament">Unreal Tournament</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Epic_Official' aria-labelledby='p-Epic_Official-label'>
	<h3 id='p-Epic_Official-label'>Epic Official</h3>
	<div class="body">
		<ul>
			<li id="n-Website"><a href="https://www.unrealengine.com" rel="nofollow">Website</a></li>
			<li id="n-Learning-Resources"><a href="https://docs.unrealengine.com/latest/INT/" rel="nofollow">Learning Resources</a></li>
			<li id="n-Forums"><a href="https://forums.unrealengine.com/" rel="nofollow">Forums</a></li>
			<li id="n-Blog"><a href="https://www.unrealengine.com/blog" rel="nofollow">Blog</a></li>
			<li id="n-YouTube"><a href="https://www.youtube.com/UnrealEngine" rel="nofollow">YouTube</a></li>
			<li id="n-Twitch"><a href="http://www.twitch.tv/unrealengine" rel="nofollow">Twitch</a></li>
			<li id="n-Twitter"><a href="https://twitter.com/UnrealEngine" rel="nofollow">Twitter</a></li>
			<li id="n-Facebook"><a href="https://www.facebook.com/UnrealEngine" rel="nofollow">Facebook</a></li>
			<li id="n-Instagram"><a href="https://instagram.com/unrealengine/" rel="nofollow">Instagram</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/Procedural_Mesh_Generation" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/Procedural_Mesh_Generation" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="/index.php?title=Procedural_Mesh_Generation&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
						</div>
					</div>
				</div>				
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/Procedural_Mesh_Generation"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="/Talk:Procedural_Mesh_Generation"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="/Procedural_Mesh_Generation" >View</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="/index.php?title=Procedural_Mesh_Generation&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/index.php?title=Procedural_Mesh_Generation&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">History</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-createaccount"><a href="/index.php?title=Special:UserLogin&amp;returnto=Procedural+Mesh+Generation&amp;returntoquery=action%3Dedit&amp;type=signup">Create account</a></li><li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=Procedural+Mesh+Generation&amp;returntoquery=action%3Dedit" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>	</ul>
</div>
				</div>
			</div>
		</div>
		<div id="maincol">
		<div class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- Start of crumbs links -->
			<div class="crumbs">
			<p>
							</p>
			</div>
			<!-- End of crumbs links -->
			<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for Procedural Mesh Generation</span></h1>
			<div id="bodyContent">
				<div id="contentSub">‚Üê <a href="/Procedural_Mesh_Generation" title="Procedural Mesh Generation">Procedural Mesh Generation</a></div>
																<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in the group: <a href="/index.php?title=Epic_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Epic Wiki:Users (page does not exist)">Users</a>.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Rating|Type=Article|Versions=4.7}}

This is a very simple demonstration on how to generate procedural meshes and spawn them in game. It is not to be taken as an example of proper programming technique, but only as an indication to help you generate your own meshes.

You can '''[https://github.com/SRombauts/UE4ProceduralMesh/ get this up-to-date demo code in a working UE 4.7 project on GitHub]'''. Please note that this no longer works in 4.8 because Epic added an [https://docs.unrealengine.com/latest/INT/BlueprintAPI/Components/ProceduralMesh/index.html official component with the same name (UProceduralMeshComponent) and similar functionality] (see also [[Procedural Mesh Component in C++:Getting Started]]).

The following assumes you already have a project created. However, you will need to add RHI, RenderCore and ShaderCore modules in your build file.

&lt;syntaxhighlight lang="cpp">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "RHI", "RenderCore", "ShaderCore" });
&lt;/syntaxhighlight>

== Creating a Generated Mesh class ==

The Unreal Engine 4 sources come with a CustomMeshComponent under Engine\Plugins\Runtime\CustomMeshComponent. I had trouble with using it as a plugin (link error), so I have reimplemented it. Essentially, copy the files to your project and rename them GeneratedMeshComponent (.h/.cpp). Replace all occurences of "Custom" to "Generated". You will need to add your project header to the cpp file. Otherwise, the code as I have use it is untouched.

Here they are as they appear in my test project:

=== GeneratedMeshComponent.h ===
&lt;syntaxhighlight lang="cpp">
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GeneratedMeshComponent.generated.h"

USTRUCT(BlueprintType)
struct FGeneratedMeshTriangle
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, Category=Triangle)
	FVector Vertex0;

	UPROPERTY(EditAnywhere, Category=Triangle)
	FVector Vertex1;

	UPROPERTY(EditAnywhere, Category=Triangle)
	FVector Vertex2;
};

/** Component that allows you to specify custom triangle mesh geometry */
UCLASS(editinlinenew, meta=(BlueprintSpawnableComponent), ClassGroup=Rendering)
class UGeneratedMeshComponent : public UMeshComponent, public IInterface_CollisionDataProvider 
{
	GENERATED_UCLASS_BODY()

public:
	/** Set the geometry to use on this triangle mesh */
	UFUNCTION(BlueprintCallable, Category="Components|GeneratedMesh")
	bool SetGeneratedMeshTriangles(const TArray&lt;FGeneratedMeshTriangle>&amp; Triangles);

	/** Description of collision */
	UPROPERTY(BlueprintReadOnly, Category="Collision")
	class UBodySetup* ModelBodySetup;

	// Begin UMeshComponent interface.
	virtual int32 GetNumMaterials() const OVERRIDE;
	// End UMeshComponent interface.

	// Begin Interface_CollisionDataProvider Interface
	virtual bool GetPhysicsTriMeshData(struct FTriMeshCollisionData* CollisionData, bool InUseAllTriData) OVERRIDE;
	virtual bool ContainsPhysicsTriMeshData(bool InUseAllTriData) const OVERRIDE;
	virtual bool WantsNegXTriMesh() OVERRIDE { return false; }
	// End Interface_CollisionDataProvider Interface

	// Begin UPrimitiveComponent interface.
	virtual FPrimitiveSceneProxy* CreateSceneProxy() OVERRIDE;
	virtual class UBodySetup* GetBodySetup() OVERRIDE;
	// End UPrimitiveComponent interface.

	void UpdateBodySetup();
	void UpdateCollision();
private:



	// Begin USceneComponent interface.
	virtual FBoxSphereBounds CalcBounds(const FTransform &amp; LocalToWorld) const OVERRIDE;
	// Begin USceneComponent interface.

	/** */
	TArray&lt;FGeneratedMeshTriangle> GeneratedMeshTris;

	friend class FGeneratedMeshSceneProxy;
};
&lt;/syntaxhighlight>

=== GeneratedMeshComponent.cpp ===
&lt;syntaxhighlight lang="cpp">
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved. 
#include "MyProject5.h"
#include "DynamicMeshBuilder.h"
#include "GeneratedMeshComponent.h"
#include "Runtime/Launch/Resources/Version.h" // for ENGINE_xxx_VERSION

/** Vertex Buffer */
class FGeneratedMeshVertexBuffer : public FVertexBuffer 
{
public:
	TArray&lt;FDynamicMeshVertex> Vertices;

	virtual void InitRHI()
	{
#if ENGINE_MAJOR_VERSION >= 4 &amp;&amp; ENGINE_MINOR_VERSION >= 3
                FRHIResourceCreateInfo CreateInfo;
		VertexBufferRHI = RHICreateVertexBuffer(Vertices.Num() * sizeof(FDynamicMeshVertex),BUF_Static,CreateInfo);
#else
		VertexBufferRHI = RHICreateVertexBuffer(Vertices.Num() * sizeof(FDynamicMeshVertex),NULL,BUF_Static);
#endif
		// Copy the vertex data into the vertex buffer.
		void* VertexBufferData = RHILockVertexBuffer(VertexBufferRHI,0,Vertices.Num() * sizeof(FDynamicMeshVertex), RLM_WriteOnly);
		FMemory::Memcpy(VertexBufferData,Vertices.GetTypedData(),Vertices.Num() * sizeof(FDynamicMeshVertex));
		RHIUnlockVertexBuffer(VertexBufferRHI);

	}

};

/** Index Buffer */
class FGeneratedMeshIndexBuffer : public FIndexBuffer 
{
public:
	TArray&lt;int32> Indices;

	virtual void InitRHI()
	{
#if ENGINE_MAJOR_VERSION >= 4 &amp;&amp; ENGINE_MINOR_VERSION >= 3
                FRHIResourceCreateInfo CreateInfo;
		IndexBufferRHI = RHICreateIndexBuffer(sizeof(int32),Indices.Num() * sizeof(int32),BUF_Static,CreateInfo);
#else
		IndexBufferRHI = RHICreateIndexBuffer(sizeof(int32),Indices.Num() * sizeof(int32),NULL,BUF_Static);
#endif
		// Write the indices to the index buffer.
		void* Buffer = RHILockIndexBuffer(IndexBufferRHI,0,Indices.Num() * sizeof(int32),RLM_WriteOnly);
		FMemory::Memcpy(Buffer,Indices.GetTypedData(),Indices.Num() * sizeof(int32));
		RHIUnlockIndexBuffer(IndexBufferRHI);
	}
};

/** Vertex Factory */
class FGeneratedMeshVertexFactory : public FLocalVertexFactory
{
public:

	FGeneratedMeshVertexFactory()
	{}


	/** Initialization */
	void Init(const FGeneratedMeshVertexBuffer* VertexBuffer)
	{
		check(!IsInRenderingThread());

		ENQUEUE_UNIQUE_RENDER_COMMAND_TWOPARAMETER(
			InitGeneratedMeshVertexFactory,
			FGeneratedMeshVertexFactory*,VertexFactory,this,
			const FGeneratedMeshVertexBuffer*,VertexBuffer,VertexBuffer,
		{
			// Initialize the vertex factory's stream components.
			DataType NewData;
			NewData.PositionComponent = STRUCTMEMBER_VERTEXSTREAMCOMPONENT(VertexBuffer,FDynamicMeshVertex,Position,VET_Float3);
			NewData.TextureCoordinates.Add(
				FVertexStreamComponent(VertexBuffer,STRUCT_OFFSET(FDynamicMeshVertex,TextureCoordinate),sizeof(FDynamicMeshVertex),VET_Float2)
				);
			NewData.TangentBasisComponents[0] = STRUCTMEMBER_VERTEXSTREAMCOMPONENT(VertexBuffer,FDynamicMeshVertex,TangentX,VET_PackedNormal);
			NewData.TangentBasisComponents[1] = STRUCTMEMBER_VERTEXSTREAMCOMPONENT(VertexBuffer,FDynamicMeshVertex,TangentZ,VET_PackedNormal);
			NewData.ColorComponent = STRUCTMEMBER_VERTEXSTREAMCOMPONENT(VertexBuffer, FDynamicMeshVertex, Color, VET_Color);
			VertexFactory->SetData(NewData);
		});
	}
};



//////////////////////////////////////////////////////////////////////////

UGeneratedMeshComponent::UGeneratedMeshComponent( const FPostConstructInitializeProperties&amp; PCIP )
	: Super( PCIP )
{
	PrimaryComponentTick.bCanEverTick = false;

}

bool UGeneratedMeshComponent::SetGeneratedMeshTriangles(const TArray&lt;FGeneratedMeshTriangle>&amp; Triangles)
{
	GeneratedMeshTris = Triangles;

	UpdateCollision();

	// Need to recreate scene proxy to send it over
	MarkRenderStateDirty();

	return true;
}


FPrimitiveSceneProxy* UGeneratedMeshComponent::CreateSceneProxy()
{
	
	/** Scene proxy defined only inside the scope of this one function */
	class FGeneratedMeshSceneProxy : public FPrimitiveSceneProxy
	{
	public:

		FGeneratedMeshSceneProxy(UGeneratedMeshComponent* Component)
			: FPrimitiveSceneProxy(Component)
#if ENGINE_MAJOR_VERSION >= 4 &amp;&amp; ENGINE_MINOR_VERSION >= 5
			, MaterialRelevance(Component->GetMaterialRelevance(ERHIFeatureLevel::SM4)) // Feature level defined by the capabilities of DX10 Shader Model 4.
#else
			, MaterialRelevance(Component->GetMaterialRelevance())
#endif
		{
			const FColor VertexColor(255,255,255);

			// Add each triangle to the vertex/index buffer
			for(int TriIdx=0; TriIdx&lt;Component->GeneratedMeshTris.Num(); TriIdx++)
			{
				FGeneratedMeshTriangle&amp; Tri = Component->GeneratedMeshTris[TriIdx];

				const FVector Edge01 = (Tri.Vertex1 - Tri.Vertex0);
				const FVector Edge02 = (Tri.Vertex2 - Tri.Vertex0);

				const FVector TangentX = Edge01.SafeNormal();
				const FVector TangentZ = (Edge02 ^ Edge01).SafeNormal();
				const FVector TangentY = (TangentX ^ TangentZ).SafeNormal();

				FDynamicMeshVertex Vert0;
				Vert0.Position = Tri.Vertex0;
				Vert0.Color = VertexColor;
				Vert0.SetTangents(TangentX, TangentY, TangentZ);
				int32 VIndex = VertexBuffer.Vertices.Add(Vert0);
				IndexBuffer.Indices.Add(VIndex);

				FDynamicMeshVertex Vert1;
				Vert1.Position = Tri.Vertex1;
				Vert1.Color = VertexColor;
				Vert1.SetTangents(TangentX, TangentY, TangentZ);
				VIndex = VertexBuffer.Vertices.Add(Vert1);
				IndexBuffer.Indices.Add(VIndex);

				FDynamicMeshVertex Vert2;
				Vert2.Position = Tri.Vertex2;
				Vert2.Color = VertexColor;
				Vert2.SetTangents(TangentX, TangentY, TangentZ);
				VIndex = VertexBuffer.Vertices.Add(Vert2);
				IndexBuffer.Indices.Add(VIndex);
			}

			// Init vertex factory
			VertexFactory.Init(&amp;VertexBuffer);

			// Enqueue initialization of render resource
			BeginInitResource(&amp;VertexBuffer);
			BeginInitResource(&amp;IndexBuffer);
			BeginInitResource(&amp;VertexFactory);

			// Grab material
			Material = Component->GetMaterial(0);
			if(Material == NULL)
			{
				Material = UMaterial::GetDefaultMaterial(MD_Surface);
			}
		}

		virtual ~FGeneratedMeshSceneProxy()
		{
			VertexBuffer.ReleaseResource();
			IndexBuffer.ReleaseResource();
			VertexFactory.ReleaseResource();
		}

		virtual void DrawDynamicElements(FPrimitiveDrawInterface* PDI,const FSceneView* View)
		{
			QUICK_SCOPE_CYCLE_COUNTER( STAT_GeneratedMeshSceneProxy_DrawDynamicElements );

			const bool bWireframe = View->Family->EngineShowFlags.Wireframe;

			auto WireframeMaterialInstance = new FColoredMaterialRenderProxy(
				GEngine->WireframeMaterial ? GEngine->WireframeMaterial->GetRenderProxy(IsSelected()) : NULL,
				FLinearColor(0, 0.5f, 1.f)
				);

			FMaterialRenderProxy* MaterialProxy = NULL;
			if(bWireframe)
			{
				MaterialProxy = &amp;WireframeMaterialInstance;
			}
			else
			{
				MaterialProxy = Material->GetRenderProxy(IsSelected());
			}

			// Draw the mesh.
			FMeshBatch Mesh;
			FMeshBatchElement&amp; BatchElement = Mesh.Elements[0];
			BatchElement.IndexBuffer = &amp;IndexBuffer;
			Mesh.bWireframe = bWireframe;
			Mesh.VertexFactory = &amp;VertexFactory;
			Mesh.MaterialRenderProxy = MaterialProxy;
#if ENGINE_MAJOR_VERSION >= 4 &amp;&amp; ENGINE_MINOR_VERSION >= 5
			BatchElement.PrimitiveUniformBuffer = CreatePrimitiveUniformBufferImmediate(GetLocalToWorld(), GetBounds(), GetLocalBounds(), true, UseEditorDepthTest());
#else
			BatchElement.PrimitiveUniformBuffer = CreatePrimitiveUniformBufferImmediate(GetLocalToWorld(), GetBounds(), GetLocalBounds(), true);
#endif
			BatchElement.FirstIndex = 0;
			BatchElement.NumPrimitives = IndexBuffer.Indices.Num() / 3;
			BatchElement.MinVertexIndex = 0;
			BatchElement.MaxVertexIndex = VertexBuffer.Vertices.Num() - 1;
			Mesh.ReverseCulling = IsLocalToWorldDeterminantNegative();
			Mesh.Type = PT_TriangleList;
			Mesh.DepthPriorityGroup = SDPG_World;
			PDI->DrawMesh(Mesh);
		}

		virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View)
		{
			FPrimitiveViewRelevance Result;
			Result.bDrawRelevance = IsShown(View);
			Result.bShadowRelevance = IsShadowCast(View);
			Result.bDynamicRelevance = true;
			MaterialRelevance.SetPrimitiveViewRelevance(Result);
			return Result;
		}

		virtual bool CanBeOccluded() const OVERRIDE
		{
			return !MaterialRelevance.bDisableDepthTest;
		}

		virtual uint32 GetMemoryFootprint( void ) const { return( sizeof( *this ) + GetAllocatedSize() ); }

		uint32 GetAllocatedSize( void ) const { return( FPrimitiveSceneProxy::GetAllocatedSize() ); }

	private:

		UMaterialInterface* Material;
		FGeneratedMeshVertexBuffer VertexBuffer;
		FGeneratedMeshIndexBuffer IndexBuffer;
		FGeneratedMeshVertexFactory VertexFactory;

		FMaterialRelevance MaterialRelevance;
	};
	
	
	//Only create if have enough tris
	if(GeneratedMeshTris.Num() > 0)
	{
		return new FGeneratedMeshSceneProxy(this);
	}
	else
	{
		return nullptr;
	}
}

int32 UGeneratedMeshComponent::GetNumMaterials() const
{
	return 1;
}


FBoxSphereBounds UGeneratedMeshComponent::CalcBounds(const FTransform &amp; LocalToWorld) const
{
	// Minimum Vector: It's set to the first vertex's position initially (NULL == FVector::ZeroVector might be required and a known vertex vector has intrinsically valid values)
	FVector vecMin = GeneratedMeshTris[0].Vertex0;

	// Maximum Vector: It's set to the first vertex's position initially (NULL == FVector::ZeroVector might be required and a known vertex vector has intrinsically valid values)
	FVector vecMax = GeneratedMeshTris[0].Vertex0;

	// Get maximum and minimum X, Y and Z positions of vectors
	for (int32 TriIdx = 0; TriIdx &lt; GeneratedMeshTris.Num(); TriIdx++)
	{
		vecMin.X = (vecMin.X > GeneratedMeshTris[TriIdx].Vertex0.X) ? GeneratedMeshTris[TriIdx].Vertex0.X : vecMin.X;
		vecMin.X = (vecMin.X > GeneratedMeshTris[TriIdx].Vertex1.X) ? GeneratedMeshTris[TriIdx].Vertex1.X : vecMin.X;
		vecMin.X = (vecMin.X > GeneratedMeshTris[TriIdx].Vertex2.X) ? GeneratedMeshTris[TriIdx].Vertex2.X : vecMin.X;

		vecMin.Y = (vecMin.Y > GeneratedMeshTris[TriIdx].Vertex0.Y) ? GeneratedMeshTris[TriIdx].Vertex0.Y : vecMin.Y;
		vecMin.Y = (vecMin.Y > GeneratedMeshTris[TriIdx].Vertex1.Y) ? GeneratedMeshTris[TriIdx].Vertex1.Y : vecMin.Y;
		vecMin.Y = (vecMin.Y > GeneratedMeshTris[TriIdx].Vertex2.Y) ? GeneratedMeshTris[TriIdx].Vertex2.Y : vecMin.Y;

		vecMin.Z = (vecMin.Z > GeneratedMeshTris[TriIdx].Vertex0.Z) ? GeneratedMeshTris[TriIdx].Vertex0.Z : vecMin.Z;
		vecMin.Z = (vecMin.Z > GeneratedMeshTris[TriIdx].Vertex1.Z) ? GeneratedMeshTris[TriIdx].Vertex1.Z : vecMin.Z;
		vecMin.Z = (vecMin.Z > GeneratedMeshTris[TriIdx].Vertex2.Z) ? GeneratedMeshTris[TriIdx].Vertex2.Z : vecMin.Z;

		vecMax.X = (vecMax.X &lt; GeneratedMeshTris[TriIdx].Vertex0.X) ? GeneratedMeshTris[TriIdx].Vertex0.X : vecMax.X;
		vecMax.X = (vecMax.X &lt; GeneratedMeshTris[TriIdx].Vertex1.X) ? GeneratedMeshTris[TriIdx].Vertex1.X : vecMax.X;
		vecMax.X = (vecMax.X &lt; GeneratedMeshTris[TriIdx].Vertex2.X) ? GeneratedMeshTris[TriIdx].Vertex2.X : vecMax.X;

		vecMax.Y = (vecMax.Y &lt; GeneratedMeshTris[TriIdx].Vertex0.Y) ? GeneratedMeshTris[TriIdx].Vertex0.Y : vecMax.Y;
		vecMax.Y = (vecMax.Y &lt; GeneratedMeshTris[TriIdx].Vertex1.Y) ? GeneratedMeshTris[TriIdx].Vertex1.Y : vecMax.Y;
		vecMax.Y = (vecMax.Y &lt; GeneratedMeshTris[TriIdx].Vertex2.Y) ? GeneratedMeshTris[TriIdx].Vertex2.Y : vecMax.Y;

		vecMax.Z = (vecMax.Z &lt; GeneratedMeshTris[TriIdx].Vertex0.Z) ? GeneratedMeshTris[TriIdx].Vertex0.Z : vecMax.Z;
		vecMax.Z = (vecMax.Z &lt; GeneratedMeshTris[TriIdx].Vertex1.Z) ? GeneratedMeshTris[TriIdx].Vertex1.Z : vecMax.Z;
		vecMax.Z = (vecMax.Z &lt; GeneratedMeshTris[TriIdx].Vertex2.Z) ? GeneratedMeshTris[TriIdx].Vertex2.Z : vecMax.Z;
	}
	
	FVector vecOrigin = ((vecMax - vecMin) / 2) + vecMin;	/* Origin = ((Max Vertex's Vector - Min Vertex's Vector) / 2 ) + Min Vertex's Vector */
	FVector BoxPoint = vecMax - vecMin;			/* The difference between the "Maximum Vertex" and the "Minimum Vertex" is our actual Bounds Box */
	return FBoxSphereBounds(vecOrigin, BoxPoint, BoxPoint.Size()).TransformBy(LocalToWorld);
}


bool UGeneratedMeshComponent::GetPhysicsTriMeshData(struct FTriMeshCollisionData* CollisionData, bool InUseAllTriData)
{
	FTriIndices Triangle;

	for(int32 i=0;i&lt;GeneratedMeshTris.Num();i++) {
		const FGeneratedMeshTriangle&amp; tri = GeneratedMeshTris[i];

		Triangle.v0 = CollisionData->Vertices.Add(tri.Vertex0);
		Triangle.v1 = CollisionData->Vertices.Add(tri.Vertex1);
		Triangle.v2 = CollisionData->Vertices.Add(tri.Vertex2);
		
		CollisionData->Indices.Add(Triangle);
		CollisionData->MaterialIndices.Add(i);
	}

	CollisionData->bFlipNormals = true;
	
	return true;
}

bool UGeneratedMeshComponent::ContainsPhysicsTriMeshData(bool InUseAllTriData) const
{
	return (GeneratedMeshTris.Num() > 0);
}

void UGeneratedMeshComponent::UpdateBodySetup() {
	if (ModelBodySetup == NULL)	{
		ModelBodySetup = ConstructObject&lt;UBodySetup>(UBodySetup::StaticClass(), this);
		ModelBodySetup->CollisionTraceFlag = CTF_UseComplexAsSimple;
		ModelBodySetup->bMeshCollideAll = true;
	}
}

void UGeneratedMeshComponent::UpdateCollision() {
	if (bPhysicsStateCreated) {
		DestroyPhysicsState();
		UpdateBodySetup();
		CreatePhysicsState();

                ModelBodySetup->InvalidatePhysicsData(); //Will not work in Packaged build
                                                         //Epic needs to add support for this
		ModelBodySetup->CreatePhysicsMeshes();
	}
}

UBodySetup* UGeneratedMeshComponent::GetBodySetup() {
	UpdateBodySetup();
	return ModelBodySetup;
}
&lt;/syntaxhighlight>

== Creating a Generated Actor Class ==
Next you need to create an Actor-derived class so you can attach the UGeneratedMeshComponent to it and spawn it. Also, to make it accessible to blueprints. Note that this example class should have a TArray&lt;FVector>&amp; input parameter to describe the polyline we are going to rotate, but for our purposes the polyline has been hardcoded.

Create a new class called GameGeneratedActor (i.e. AGameGeneratedActor). There is also a Lathe function that I am including which is very simple, just for the purposes of this exercise. Here's the source for it:

=== GameGeneratedActor.h ===
&lt;syntaxhighlight lang="cpp">
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameFramework/Actor.h"
#include "GeneratedMeshComponent.h"
#include "GameGeneratedActor.generated.h"

/**
 * 
 */
UCLASS()
class AGameGeneratedActor : public AActor
{
	GENERATED_UCLASS_BODY()

	void Lathe(const TArray&lt;FVector>&amp; points, TArray&lt;FGeneratedMeshTriangle>&amp; triangles, int segments = 64);
	
};
&lt;/syntaxhighlight>

=== GameGeneratedActor.cpp ===
&lt;syntaxhighlight lang="cpp">
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.

#include "MyProject5.h"
#include "GameGeneratedActor.h"

AGameGeneratedActor::AGameGeneratedActor(const class FPostConstructInitializeProperties&amp; PCIP)
	: Super(PCIP)
{
	
	UGeneratedMeshComponent* mesh = PCIP.CreateDefaultSubobject&lt;UGeneratedMeshComponent>(this, TEXT("GeneratedMesh"));

	//Contains the points describing the polyline we are going to rotate
	TArray&lt;FVector> points;

	points.Add(FVector(20, 5, 0));
	points.Add(FVector(15, 6, 0));
	points.Add(FVector(12, 7, 0));
	points.Add(FVector(11, 8, 0));
	points.Add(FVector(8, 7, 0));
	points.Add(FVector(7, 6, 0));
	points.Add(FVector(4, 5, 0));
	points.Add(FVector(3, 4, 0));
	points.Add(FVector(2, 3, 0));
	points.Add(FVector(1, 4, 0));

	TArray&lt;FGeneratedMeshTriangle> triangles;
	Lathe(points, triangles,128);
	mesh->SetGeneratedMeshTriangles(triangles);
	
	RootComponent = mesh;
}

void AGameGeneratedActor::Lathe(const TArray&lt;FVector>&amp; points, TArray&lt;FGeneratedMeshTriangle>&amp; triangles, int segments) {
	UE_LOG(LogClass, Log, TEXT("AGameGeneratedActor::Lathe POINTS %d"), points.Num());

	TArray&lt;FVector> verts;

	// precompute some trig
	float angle = FMath::DegreesToRadians(360.0f / segments);
	float sinA = FMath::Sin(angle);
	float cosA = FMath::Cos(angle);

	/*
	This implementation is rotation around the X Axis, other formulas below
	
	Z Axis Rotation
	x' = x*cos q - y*sin q
	y' = x*sin q + y*cos q
	z' = z

	X Axis Rotation
	y' = y*cos q - z*sin q
	z' = y*sin q + z*cos q
	x' = x

	Y Axis Rotation
	z' = z*cos q - x*sin q
	x' = z*sin q + x*cos q
	y' = y
	*/

	//Working point array, in which we keep the rotated line we draw with
	TArray&lt;FVector> wp;
	for (int i = 0; i &lt; points.Num(); i++) {
		wp.Add(points[i]);
	}

	// Add a first and last point on the axis to complete the triangles
	FVector p0(wp[0].X, 0, 0);
	FVector pLast(wp[wp.Num() - 1].X, 0, 0);

	FGeneratedMeshTriangle tri;
	//for each segment draw the triangles clockwise for normals pointing out or counterclockwise for the opposite (this here does CW)
	for (int segment = 0; segment&lt;segments; segment++) {

		for (int i = 0; i&lt;points.Num() - 1; i++) {
			FVector p1 = wp[i];
			FVector p2 = wp[i + 1];
			FVector p1r(p1.X, p1.Y*cosA - p1.Z*sinA, p1.Y*sinA + p1.Z*cosA);
			FVector p2r(p2.X, p2.Y*cosA - p2.Z*sinA, p2.Y*sinA + p2.Z*cosA);

			if (i == 0) {
				tri.Vertex0 = p1;
				tri.Vertex1 = p0;
				tri.Vertex2 = p1r;
				triangles.Add(tri);
			}

			tri.Vertex0 = p1;
			tri.Vertex1 = p1r;
			tri.Vertex2 = p2;
			triangles.Add(tri);

			tri.Vertex0 = p2;
			tri.Vertex1 = p1r;
			tri.Vertex2 = p2r;
			triangles.Add(tri);

			if (i == points.Num() - 2) {
				tri.Vertex0 = p2;
				tri.Vertex1 = p2r;
				tri.Vertex2 = pLast;
				triangles.Add(tri);
				wp[i + 1] = p2r;
			}

			wp[i] = p1r;
		}
	}
}


&lt;/syntaxhighlight>

== Spawning the Actor ==
Once the project has been compiled, the new classes are accessible by Blueprints. So you will need to hook up a SpawnActor in some blueprint and set its class to GameGeneratedActor(I used a PlayerController, and its hooked to a HUD event), and it should look like this (note: I use the transform before and after as it seems to not consider scale on the spawn. In this example I suggest a scale of 10, otherwise the object will be too small)

[[File:SpawnActorBlueprintExample.png]]

Once you run the game and trigger the spawn, it should look like this:

[[File:GeneratedMeshExample.png]]

For more info, see this thread: [https://forums.unrealengine.com/showthread.php?1552-Generate-Procedural-Mesh Generate Procedural Mesh]

Enjoy!

== Connecting standard UCustomMeshComponent ==
If you want to avoid code duplication and standard functionality of UCustomMeshComponent is more than enough for you, you can try to connect CustomMeshPlugin. To avoid link error you should use import/export macro for class: 

&lt;syntaxhighlight lang="cpp">
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.

#pragma once

...

/** Component that allows you to specify custom triangle mesh geometry */
UCLASS(hidecategories=(Object,LOD, Physics, Collision), editinlinenew, meta=(BlueprintSpawnableComponent), ClassGroup=Rendering)
class CUSTOMMESHCOMPONENT_API UCustomMeshComponent : public UMeshComponent
&lt;/syntaxhighlight>

== Blueprint implementation ==
If you want to be able to generate a mesh from blueprints you can do this: 

&lt;syntaxhighlight lang="cpp">
#include "GameFramework/Actor.h"
#include "ProceduralMeshComponent.h"
#include "CustomMeshBridge.generated.h"


/**
 *  code by Frederic Artus Nieto
 */
UCLASS()
class SSS2_API ACustomMeshBridge : public AActor
{
	GENERATED_UCLASS_BODY()
public:

	UFUNCTION(BlueprintPure, meta = (FriendlyName = "Make Triangle", Keywords = "New Triangle"), Category = ProceduralMesh)
		static FGeneratedMeshTriangle CreateTriangle(FVector vertex0, FVector vertex1, FVector vertex2);

	UFUNCTION(BlueprintCallable, meta = (FriendlyName = "Set Mesh Material", Keywords = "Set Mesh Material"), Category = ProceduralMesh)
		static void SetMeshMaterial(UProceduralMeshComponent* component, UMaterialInterface* Material);

	UFUNCTION(BlueprintCallable, meta = (FriendlyName = "Set Mesh Triangles", Keywords = "Set Mesh Triangles"), Category = ProceduralMesh)
		static void SetMeshTriangles(UProceduralMeshComponent* component, TArray&lt;FGeneratedMeshTriangle> Triangles);

};
&lt;/syntaxhighlight>
&lt;syntaxhighlight lang="cpp">
// code by Frederic Artus Nieto
#include "SSS2.h"
#include "DynamicMeshBuilder.h"
#include "CustomMeshBridge.h"
#include "ConstructorHelpers.h"

ACustomMeshBridge::ACustomMeshBridge(const class FPostConstructInitializeProperties&amp; PCIP)
	: Super(PCIP)
{
}

FGeneratedMeshTriangle ACustomMeshBridge::CreateTriangle(FVector vertex0, FVector vertex1, FVector vertex2)
{
	FGeneratedMeshTriangle tri;
	tri.Vertex0 = vertex0;
	tri.Vertex1 = vertex1;
	tri.Vertex2 = vertex2;
	return tri;
}

void ACustomMeshBridge::SetMeshMaterial(GameGeneratedActor * component, UMaterialInterface* Material)
{
	component->SetMaterial(0, Material);
}

void ACustomMeshBridge::SetMeshTriangles(GameGeneratedActor * component, TArray&lt;FGeneratedMeshTriangle> Triangles)
{
	component->SetProceduralMeshTriangles(Triangles);
}
&lt;/syntaxhighlight>

Once you made this class, you will see some new nodes in the ProceduralMesh tab when you select a new node in the blueprint editor (you have to untick "Context Sensitive").
Note that you do need to have a GameGeneratedActor component in your actor to do that. 

You then have to use the SetMeshTriangles node to apply the new triangles to the GameGeneratedActor.
You can do it during runtime to make animated meshes (I had some laggy experience when updating too many vertices). 
You can apply a material to the mesh with the SetMeshMaterial node if you want. Note that there are no UVs.

== Changelog ==
=== Update 1 ===
The UGeneratedMeshComponent class has been updated to include collisions. However, this is currently only available within the Editor, as it is related to cooking physics at runtime (which is not supported outside the Editor at this time). Epic will include the capability for version 4.2 or 4.3. See [https://forums.unrealengine.com/showthread.php?2695-Implement-Runtime-Collision-Detection-for-Procedural-Generated-Meshes this thread] and [https://forums.unrealengine.com/showthread.php?2078-How-to-create-collision-information-for-procedural-geometry this thread]. Thanks to all who participated in those threads for pointers, credit goes to them. Remember to set SetActorCollisionsEnabled(true) in your Actor! [[User:Dmacesic|Dmacesic]] ([[User talk:Dmacesic|talk]]) 18:04, 11 April 2014 (UTC)

=== Update 2 ===
Added vertex color fix from Ryvar as per [https://forums.unrealengine.com/showthread.php?1552-Generate-Procedural-Mesh&amp;p=50833&amp;viewfull=1#post50833 this post].

=== Update 3 ===
RHICreateXXXBuffer function signature changed for 4.3.  Put in macro code to make code work both for 4.2 and 4.3

=== Update 4 ===
Code updated for UE4.5 : #include Version.h for ENGINE_MINOR_VERSION macro, GetMaterialRelevance(::SM5) , CreatePrimitiveUniformBufferImmediate() with UseEditorDepthTest() and comments on mesh collision in cooked game.

=== Update 5 ===
Add information about solving link problem.

=== Update 6 ===
Added an example of blueprint implementation.
If you made a little build please post a screen of the bluprint if none is there.


== External link ==
* [https://github.com/SRombauts/UE4ProceduralMesh/ Get this demo code in a working UE 4.7 project on GitHub].

 [[Category:Code]]
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Template used on this page:
</p></div><ul>
<li><a href="/Template:Rating" title="Template:Rating">Template:Rating</a> (<a href="/index.php?title=Template:Rating&amp;action=edit" title="Template:Rating">view source</a>) (protected)</li></ul></div><p id="mw-returnto">Return to <a href="/Procedural_Mesh_Generation" title="Procedural Mesh Generation">Procedural Mesh Generation</a>.</p>
</div>												<div class="printfooter">
				Retrieved from "<a href="https://wiki.unrealengine.com/Procedural_Mesh_Generation">https://wiki.unrealengine.com/Procedural_Mesh_Generation</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		</div>
		</div>
		
		<div id="footer">
			<div id="brand">

			</div>
			<div id="legal">
				<div id="copyright">
					&copy; 2004-2015, Epic Games, Inc. All rights reserved. Unreal and its logo are Epic's trademarks or registered trademarks in the US and elsewhere.
				</div>
				<div id="terms">
					<a target="_blank" href="http://epicgames.com/tou">TERMS OF USE</a> | <a target="_blank" href="http://epicgames.com/privacynotice">PRIVACY POLICY</a>
				</div>
			</div>
		</div>
	</div>
		<!--<div id="footer" role="contentinfo">
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<div name="copyright">&#169; 2004-2014, Epic Games, Inc. All rights reserved. Epic Games, Unreal, Unreal Engine, Unreal Tournament, and their respective logos are Epic's trademarks or registered trademarks in the US and elsewhere.</div>
					</li>
					<li id="footer-termsofuseico">
						<div name="termsofuse"><a href="http://epicgames.com/tou" target="_blank">Terms of Use</a></div>
					</li>
					<li id="footer-privacynoticeico">
						<div name="privacynotice"><a href="http://epicgames.com/privacynotice" target="_blank">Privacy Policy</a></div>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>-->
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="/extensions/EpicSearchSystem/Javascript/Search.js?303"></script>
<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=epic&amp;*"></script>
<!-- Served in 0.073 secs. -->		<img src="https://tracking.unrealengine.com/track.png" width="1" height="1">
		<!--<script type="text/javascript">
			setTimeout(function () {
				var a = document.createElement("script");
				var b = document.getElementsByTagName("script")[0];
				a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
				a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
			}, 1);
		</script>-->
	</body>
</html>

		