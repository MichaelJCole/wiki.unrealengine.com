<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wiki.unrealengine.com</title>
    <meta name="description" content="A static site pulled from the internet archive">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css" as="style"><link rel="preload" href="/wiki.unrealengine.com/assets/js/app.aaf63946.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/2.4f53495e.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/870.b6ca1bb8.js" as="script">
    <link rel="stylesheet" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki.unrealengine.com/" class="home-link router-link-active"><!----> <span class="site-name">wiki.unrealengine.com</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>MultiThreading and synchronization Guide - Epic Wiki</p> <h1 id="multithreading-and-synchronization-guide"><a href="#multithreading-and-synchronization-guide" class="header-anchor">#</a> MultiThreading and synchronization Guide</h1> <p>From Epic Wiki</p> <p>Jump to: <a href="#mw-head">navigation</a>, <a href="#p-search">search</a></p> <p><a href="/index.php?title=Template:Rating&amp;action=edit&amp;redlink=1" title="Template:Rating (page does not exist)">Template:Rating</a></p> <h2 id="contents"><a href="#contents" class="header-anchor">#</a> Contents</h2> <ul><li><a href="#Overview">1 Overview</a></li> <li><a href="#RNGThread.H">2 RNGThread.H</a></li> <li><a href="#RNGThread.CPP">3 RNGThread.CPP</a></li> <li><a href="#Using_the_Thread_and_it.27s_methods_inside_PlayerController">4 Using the Thread and it's methods inside PlayerController</a></li> <li><a href="#Conclusion">5 Conclusion</a></li></ul> <h2 id="overview"><a href="#overview" class="header-anchor">#</a> Overview</h2> <p><strong>Author</strong> <a href="/index.php?title=User:ColdSteel48&amp;action=edit&amp;redlink=1" title="User:ColdSteel48 (page does not exist)">User:ColdSteel48</a></p> <p>Dear Community,</p> <p>Here is a little tutorial about thread synchronization and events.</p> <p>I am not going to cover the thread creating techniques since <a href="/index.php?title=User:Rama" title="User:Rama">Rama</a> did a great job on it!</p> <p>We will take a look on how to use <em>FCriticalSection</em> and <em>FEvent</em>.</p> <p>We will create a somehow similar to <a href="/index.php?title=User:Rama" title="User:Rama">Rama</a>'s thread example to compute random <em>Fvectors</em> and store them in <em>TArray</em> protected by <em>FCriticalSection</em> for thread safety and we will create a kill thread event using <em>FEvent</em>.</p> <p>We will also cover a Pause and UnPause thread with help of the same <em>FEvent</em>.</p> <h2 id="rngthread-h"><a href="#rngthread-h" class="header-anchor">#</a> RNGThread.H</h2> <p><syntaxhighlight lang="cpp"> class URPRJNAME_API RNGThreadÂ : public FRunnable { public:</syntaxhighlight></p> <div class="language- extra-class"><pre><code>   //Constructor
</code></pre></div><p>RNGThread(int Count = 50000, int minNumber = 0, int maxNumber = 1000, int chunkCount = 20); //Destructor ~RNGThread();</p> <div class="language- extra-class"><pre><code>   //Use this method to kill the thread!!
</code></pre></div><p>void EnsureCompletion();</p> <div class="language- extra-class"><pre><code>   //Pause the thread 
</code></pre></div><p>void PauseThread();</p> <div class="language- extra-class"><pre><code>   //Continue/UnPause the thread
</code></pre></div><p>void ContinueThread();</p> <p>//FRunnable interface. virtual bool Init(); virtual uint32 Run(); virtual void Stop();</p> <div class="language- extra-class"><pre><code>   bool IsThreadPaused();

   FVector GetRandomVector();        
</code></pre></div><p>private: //Thread to run the worker FRunnable on FRunnableThread* Thread;</p> <p>FCriticalSection m_mutex; FEvent * m_semaphore;</p> <p>int m_chunkCount; int m_amount; int m_MinInt; int m_MaxInt;</p> <div class="language- extra-class"><pre><code>   //As the name states those members are Thread safe
</code></pre></div><p>FThreadSafeBool m_Kill; FThreadSafeBool m_Pause;</p> <div class="language- extra-class"><pre><code>   //The array is a private member because we don't want to allow anyone from outside the class to access it since we want to ensure a thread safety.
   TArray&lt;FVector&gt; m\_RandomVecs;
</code></pre></div><p>}; </p> <h2 id="rngthread-cpp"><a href="#rngthread-cpp" class="header-anchor">#</a> RNGThread.CPP</h2> <syntaxhighlight lang="cpp"><ol><li>include &quot;URPPRJNAME.h&quot; /* To be able to use FGenericPlatformProcess */</li> <li>include &quot;RNGThread.h&quot;</li></ol> <p>RNGThread::RNGThread(int Count, int minNumber, int maxNumber, int chunkCount) { m_Kill= false; m_Pause = false;</p> <div class="language- extra-class"><pre><code>   //Initialize FEvent (as a cross platform (Confirmed Mac/Windows))
</code></pre></div><p>m_semaphore = FGenericPlatformProcess::GetSynchEventFromPool(false);;</p> <p>m_MinInt = minNumber; m_MaxInt = maxNumber;</p> <p>m_chunkCount = chunkCount;</p> <p>m_amount = Count; m_RandomVecs.Reserve(m_amount);</p> <p>Thread = FRunnableThread::Create(this, TEXT(&quot;RNGThread&quot;) , 0, TPri_BelowNormal); }</p> <p>RNGThread::~RNGThread() { if (m_semaphore) {</p> <div class="language- extra-class"><pre><code>           //Cleanup the FEvent
</code></pre></div><p>FGenericPlatformProcess::ReturnSynchEventToPool(m_semaphore); m_semaphore = nullptr; }</p> <p>if (Thread) {</p> <div class="language- extra-class"><pre><code>           //Cleanup the worker thread
</code></pre></div><p>delete Thread; Thread = nullptr; } }</p> <p>bool RNGThread::Init() {</p> <div class="language- extra-class"><pre><code>   //Init the Data 
</code></pre></div><p>m_RandomVecs.Empty(); return true; }</p> <p>uint32 RNGThread::Run() { //Initial wait before starting FPlatformProcess::Sleep(0.03);</p> <p>while (!m_Kill) { if (m_Pause) {</p> <div class="language- extra-class"><pre><code>                   //FEvent-&gt;Wait(); will &quot;sleep&quot; the thread until it will get a signal &quot;Trigger()&quot;
</code></pre></div><p>m_semaphore-&gt;Wait();</p> <p>if (m_Kill) { return 0; } } else {</p> <div class="language- extra-class"><pre><code>                   //Create temporal array (chunk)
</code></pre></div><p>TArray<FVector> ChunkArray; ChunkArray.Reserve(m_chunkCount);</FVector></p> <div class="language- extra-class"><pre><code>                   //Calculate random vectors and put them to the temporal array
                   //I did it so we won't lock/unlock FCritical section each time we generating a new FVector (Locking and Unlocking is somewhat expensive).
</code></pre></div><p>for (int i = 0; i &lt; m_chunkCount; i++) { FVector RandomVec; RandomVec.X = (float)FMath::RandRange((int)m_MinInt, (int)m_MaxInt); RandomVec.Y = (float)FMath::RandRange((int)m_MinInt, (int)m_MaxInt); RandomVec.Z = 0; ChunkArray.Emplace(RandomVec); }</p> <div class="language- extra-class"><pre><code>                   //Critical section:
</code></pre></div><p>m_mutex.Lock();</p> <div class="language- extra-class"><pre><code>                       //We are locking our FCriticalSection so no other thread will access it
                       //And thus it is a thread-safe access now

                       //Append the temporal array to the Actual storage array/
</code></pre></div><p>m_RandomVecs.Append(ChunkArray);</p> <div class="language- extra-class"><pre><code>                       //Get array size
</code></pre></div><p>int num = m_RandomVecs.Num();</p> <div class="language- extra-class"><pre><code>                      //Unlock FCriticalSection so other threads may use it.
</code></pre></div><p>m_mutex.Unlock();</p> <div class="language- extra-class"><pre><code>                   //Pause Condition - if we RandomVectors contains more vectors than m\_amount we shall pause the thread to release system resources.
</code></pre></div><p>if (num &gt; m_amount) { m_Pause = true; }</p> <div class="language- extra-class"><pre><code>                   //A little sleep between the chunks (So CPU will rest a bit -- (may be omitted))
</code></pre></div><p>FPlatformProcess::Sleep(0.1); } }</p> <p>return 0; }</p> <p>void RNGThread::PauseThread() { m_Pause = true; }</p> <p>void RNGThread::ContinueThread() { m_Pause = false;</p> <p>if (m_semaphore) {</p> <div class="language- extra-class"><pre><code>           //Here is a FEvent signal &quot;Trigger()&quot; -&gt; it will wake up the thread.
</code></pre></div><p>m_semaphore-&gt;Trigger(); } }</p> <p>void RNGThread::Stop() { m_Kill= true; //Thread kill condition &quot;while (!m_Kill){...}&quot; m_Pause = false;</p> <p>if (m_semaphore) {</p> <div class="language- extra-class"><pre><code>           //We shall signal &quot;Trigger&quot; the FEvent (in case the Thread is sleeping it shall wake up!!)
</code></pre></div><p>m_semaphore-&gt;Trigger(); } }</p> <p>//Use this method to kill the thread!! void RNGThread::EnsureCompletion() { Stop();</p> <p>if (Thread) { Thread-&gt;WaitForCompletion(); } }</p> <p>//if the array is not yet ready we will generate the vector on the caller thread. FORCEINLINE FVector GenerateRandomVecInRange(int min, int max) { FVector WanderingPoint(0, 0, 0); WanderingPoint.X = (float)FMath::RandRange((int)min, (int)max); WanderingPoint.Y = (float)FMath::RandRange((int)min, (int)max); WanderingPoint.Z = (float)FMath::RandRange((int)min, (int)max); return WanderingPoint; }</p> <p>bool RNGThread:IsThreadPaused() {</p> <div class="language- extra-class"><pre><code>   return (bool)m\_Pause;
</code></pre></div><p>}</p> <p>FVector RNGThread::GetRandomVector() {</p> <div class="language- extra-class"><pre><code>   //Here we are retrieving the Vector from our storage array in a thread safe manner 
   //Despite this is a member method of this class it will be called from another thread (most likely from the GameThread) (This is by the way true for each public member methods except the &quot;Run()&quot; method) - So we must ensure the thread safety!
   //Critical section:
</code></pre></div><p>m_mutex.Lock();</p> <div class="language- extra-class"><pre><code>   	int lastIndex = m\_RandomVecs.Num() - 1;
</code></pre></div><p>if (lastIndex &lt; 0) {</p> <div class="language- extra-class"><pre><code>                   //The array is not ready yetÂ :-0
</code></pre></div><p>m_mutex.Unlock(); //We must unlock the critical section before the return to avoid a deadlock. return GenerateRandomVecInRange(m_MinInt, m_MaxInt); }</p> <div class="language- extra-class"><pre><code>           FVector vec2ret;
</code></pre></div><p>vec2ret = m_RandomVecs[lastIndex]; m_RandomVecs.RemoveAt(lastIndex);</p> <div class="language- extra-class"><pre><code>           //Some automation: if we have less than 10% random FVectors in our array we will UnPause the thread. (maybe omitted).
           if (m\_RandomVecs.Num() &lt; m\_amount/10)
</code></pre></div><p>{ RandomVecsPoolThreadHandle-&gt;ContinueThread(); }</p> <div class="language- extra-class"><pre><code>  //Critical section ends here.
  m\_mutex.Unlock();
  
  //return random vector to the caller.
  return vec2ret; 
</code></pre></div><p>} </p></syntaxhighlight><p></p> <h2 id="using-the-thread-and-it-s-methods-inside-playercontroller"><a href="#using-the-thread-and-it-s-methods-inside-playercontroller" class="header-anchor">#</a> Using the Thread and it's methods inside PlayerController</h2> <p><syntaxhighlight lang="cpp"> //In the .h for the player controller (for example) RNGThread* RandomVecsPoolThreadHandle;</syntaxhighlight></p> <p>//Cpp //Starting For example in the BeginPlay (NOTE: Please do not start the thread in constructor!). void AMyPlayerController::BeginPlay() { Super::BeginPlay(); RandomVecsPoolThreadHandle = nullptr;</p> <div class="language- extra-class"><pre><code>   RandomVecsPoolThreadHandle = new RNGThread(/\*We will use the default values\*/);
</code></pre></div><p>}</p> <p>//Killing the thread for example in EndPlay() or BeginDestroy() void AMyPlayerController::EndPlay(const EEndPlayReason::Type EndPlayReason) { if (RandomVecsPoolThreadHandle) { if (RandomVecsPoolThreadHandle) { RandomVecsPoolThreadHandle-&gt;EnsureCompletion(); delete RandomVecsPoolThreadHandle; RandomVecsPoolThreadHandle = nullptr; } }</p> <p>Super::EndPlay(EndPlayReason); }</p> <p>void AMyPlayerController::BeginDestroy() { if (RandomVecsPoolThreadHandle) { RandomVecsPoolThreadHandle-&gt;EnsureCompletion(); delete RandomVecsPoolThreadHandle; RandomVecsPoolThreadHandle = nullptr; } Super::BeginDestroy(); }</p> <p>//Lets print the Random vectors inside the Tick for instance: void AMyPlayerController::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds);</p> <div class="language- extra-class"><pre><code>   if (RandomVecsPoolThreadHandle)
</code></pre></div><p>{</p> <div class="language- extra-class"><pre><code>        FVector myVector = RandomVecsPoolThreadHandle-&gt;GetRandomVector();
        if(GEngine)
        {
            GEngine-&gt;AddOnScreenDebugMessage(-1, 3, FColor::Yellow, FString::Printf(TEXT(&quot;MyRandomVec = (%.2f,Â %.2f,Â %.2f) &quot;), myVector.X, myVector.Y, myVector.Z ));
        }
   }
</code></pre></div><p>} </p> <h2 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion</h2> <p>That's it for nowÂ ðŸ˜ƒ Enjoy!</p> <p>Retrieved from &quot;<a href="https://wiki.unrealengine.com/index.php?title=MultiThreading_and_synchronization_Guide&amp;oldid=307" target="_blank" rel="noopener noreferrer">https://wiki.unrealengine.com/index.php?title=MultiThreading_and_synchronization_Guide&amp;oldid=307<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot;</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki.unrealengine.com/assets/js/app.aaf63946.js" defer></script><script src="/wiki.unrealengine.com/assets/js/2.4f53495e.js" defer></script><script src="/wiki.unrealengine.com/assets/js/870.b6ca1bb8.js" defer></script>
  </body>
</html>
