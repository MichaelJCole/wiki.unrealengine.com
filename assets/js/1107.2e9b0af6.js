(window.webpackJsonp=window.webpackJsonp||[]).push([[1107],{556:function(e,t,a){"use strict";a.r(t);var r=a(28),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("UE4 Transform Calculus - Part 1 - Epic Wiki")]),e._v(" "),a("h1",{attrs:{id:"ue4-transform-calculus-part-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ue4-transform-calculus-part-1"}},[e._v("#")]),e._v(" UE4 Transform Calculus - Part 1")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#UE4_Transform_Calculus_-_Part_1"}},[e._v("1 UE4 Transform Calculus - Part 1")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Motivation"}},[e._v("1.1 Motivation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Target_Audience"}},[e._v("1.2 Target Audience")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Why_.E2.80.9CCalculus.3F.E2.80.9D"}},[e._v("1.3 Why â€œCalculus?â€")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Rigid_Body_Hierarchies"}},[e._v("1.4 Rigid Body Hierarchies")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Hierarchies_as_Attachments"}},[e._v("1.4.1 Hierarchies as Attachments")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Hierarchies_as_Frames_of_Reference"}},[e._v("1.4.2 Hierarchies as Frames of Reference")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Transform_Calculus"}},[e._v("1.5 Transform Calculus")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Transforming_Vectors_and_Points"}},[e._v("1.6 Transforming Vectors and Points")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Summary"}},[e._v("1.7 Summary")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Footnotes"}},[e._v("1.7.1 Footnotes")])])])])])])]),e._v(" "),a("h1",{attrs:{id:"ue4-transform-calculus-part-1-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ue4-transform-calculus-part-1-2"}},[e._v("#")]),e._v(" UE4 Transform Calculus - Part 1")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Slate often has to deal with deep and wide hierarchies of widgets, expressing the sizes and positions of children in terms of their parents. Sometimes these are simple relationships like text in a button, but sometimes those relationships are much more complex, like a graph editing panel that might be panning and zooming across a virtual canvas.")]),e._v(" "),a("p",[e._v("As hierarchies get deeper, this relationship becomes layered. For instance, if we apply a global DPI (dots per inch) scale to our application, which itself sits in a window at some arbitrary location on the desktop, there are a series of zooms and offsets that combine to form the final position of a widget on the screen.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img1.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/3/33/Calc1img1.png",alt:"Calc1img1.png"}})])]),e._v(" "),a("p",[a("em",[e._v("[The complex relationship of slate widgets. A UE4 Editor view displaying blueprint widgets within a virtual panel within a tabwell within a window, all having a global application scale applied. The Blueprint editor must reason about the widgets in "),a("strong",[e._v("virtual canvas space")]),e._v(", implement mouse events in "),a("strong",[e._v("desktop space")]),e._v(", and render the widgets in "),a("strong",[e._v("window space")]),e._v(".]")])]),e._v(" "),a("p",[e._v("Slate must not only be able to unwind these hierarchies internally, but also provide straightforward ways for widget authors to reason about widgets in multiple spaces (ie, local, virtual canvas, window, desktop). With the addition of "),a("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Engine/UMG/UserGuide/Styling/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Render Transforms"),a("OutboundLink")],1),e._v(" to Slate, the math for computing a childâ€™s relationship to its parent became much more involved than a simple scale and offset.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img2.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/2/2c/Calc1img2.png",alt:"Calc1img2.png"}})])]),e._v(" "),a("p",[a("em",[e._v("[SlateViewer can apply an arbitrary render transform to the entire application. Now whatâ€™s the relationship of one of these widgets to its parent, or the window, or the desktop?]")])]),e._v(" "),a("p",[e._v("In fact, the historical simplicity of a child widgetâ€™s transform with respect to its parent in Slate contributed to an overall daunting task of updating hundreds of widgets to support arbitrary render transforms. We chose to focus on the core widgets that most widgets are composed of, but lots of legacy functions still exist in Slate that are used by other widgets that donâ€™t support render transforms. This series of posts will focus on a new notation for manipulating transforms, along with a C++ implementation in UE4 that Slate is using to assist with this sometimes mind-bending task.")]),e._v(" "),a("h2",{attrs:{id:"target-audience"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#target-audience"}},[e._v("#")]),e._v(" Target Audience")]),e._v(" "),a("p",[e._v("For this discussion, I assume you are already aware of basic "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_algebra",target:"_blank",rel:"noopener noreferrer"}},[e._v("linear algebra"),a("OutboundLink")],1),e._v(" and have at least cursory experience working with rigid body hierarchies in code. You should be comfortable with vectors and matrices, be able to perform basic calculations with them, and be familiar with the idea of using them to represent transformations like translation, rotation, scale, shear, etc. Some familiarity with alternate representations like quaternions etc may also be useful when we start discussing the code implementation. If youâ€™ve ever tried to use a physics engine or render something in OpenGL or Direct3D, you likely have more than enough exposure to these concepts.")]),e._v(" "),a("p",[e._v("I will generally try to keep a conversational tone, but will occasionally stray into math-heavy territory. When I do, Iâ€™ll try to summarize the salient points and provide links to read up more if youâ€™d like. The reason for â€œgetting mathyâ€ sometimes is to establish the mathematical foundation for the notation we are developing, not to rigorously prove it. Iâ€™m a programmer, not a mathematician.")]),e._v(" "),a("h2",{attrs:{id:"why-calculus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-calculus"}},[e._v("#")]),e._v(" Why â€œCalculus?â€")]),e._v(" "),a("p",[e._v("So, a word about why I chose the term â€œTransform Calculusâ€ instead of something less presumptive (like Framework or API). This document in fact describes a "),a("a",{attrs:{href:"http://www.encyclopediaofmath.org/index.php/Logical_calculus",target:"_blank",rel:"noopener noreferrer"}},[e._v("logical calculus"),a("OutboundLink")],1),e._v(", or a formalization of a logical theory[1]. These are concepts that provide a mathematical notation for uniformly expressing and manipulating transforms that transcends the representation (ie, a matrix or quaternion).")]),e._v(" "),a("p",[e._v("There happens to be an implementation in UE4, but that implementation is secondary to the underlying concepts. Also, the implementation sometimes has to make compromises to work within the C++ language and UE4 Core types, so is not a pure expression of these concepts.")]),e._v(" "),a("p",[e._v("To be clear, I'm not inventing anything \"novel\", Iâ€™m just wrapped some well-known math concepts in a higher level abstraction. That said, I do feel all the focus on notation is a critical part of the journey, as one can't use the library effectively without understanding the notation. For that reason, simply referring to this as a Framework or API seemed insufficient.")]),e._v(" "),a("p",[e._v("One could perhaps more accurately refer to this an an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Algebra_over_a_field",target:"_blank",rel:"noopener noreferrer"}},[e._v("algebra"),a("OutboundLink")],1),e._v(", as itâ€™s closed over the affine vector space. But I donâ€™t prove this, and frankly Iâ€™ve been using the term calculus for years, so it seemed too late to turn back now. Câ€™est la vie.Â ðŸ˜ƒ")]),e._v(" "),a("h2",{attrs:{id:"rigid-body-hierarchies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rigid-body-hierarchies"}},[e._v("#")]),e._v(" Rigid Body Hierarchies")]),e._v(" "),a("p",[e._v("Slate UI hierarchies are conceptually identical to rigid body hierarchies that physics engines utilize. Weâ€™ll start with a quick overview of rigid body hierarchies to establish the concepts. I expect anyone reading this to be familiar already, so I wonâ€™t dwell on details.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img3.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/8/86/Calc1img3.png",alt:"Calc1img3.png"}})])]),e._v(" "),a("h3",{attrs:{id:"hierarchies-as-attachments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hierarchies-as-attachments"}},[e._v("#")]),e._v(" Hierarchies as Attachments")]),e._v(" "),a("p",[e._v("One way to think about the hierarchy is as each part being â€œattachedâ€ to its parent by a transformation. This transformation places a child part relative to its parent. To place a part in the world we start at the root of the tree (â€œworld spaceâ€) and successively transform the part all the way down to the leaf node where the part is located.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1imgIV.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/7/70/Calc1imgIV.png",alt:"Calc1imgIV.png"}})])]),e._v(" "),a("p",[e._v("If one thinks of these transformations as simple offsets, then it is easy to conceptualize. However, most rigid body systems allow more complex transformations like scale, rotate, and/or shear. Reasoning about partsâ€™ relations to each other in such a hierarchy can quickly become very complicated.")]),e._v(" "),a("h3",{attrs:{id:"hierarchies-as-frames-of-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hierarchies-as-frames-of-reference"}},[e._v("#")]),e._v(" Hierarchies as Frames of Reference")]),e._v(" "),a("p",[e._v("Another way to look at the hierarchy is that each part is a camera, and the transformation is taking the part from itâ€™s local the coordinate system into that of the parent. So each part is essentially in itâ€™s own coordinate system, or "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Frame_of_reference",target:"_blank",rel:"noopener noreferrer"}},[e._v("â€œframe of referenceâ€"),a("OutboundLink")],1),e._v(" relative to its parent. The representation is logically equivalent to the attachment point of view described above, but instead of viewing all parts as placed at different points in the same coordinate system, each part has its own local coordinate system. This makes it easier to conceptualize the parent-child relationship as more than a simple offset. To place a child in the world, we chain, or composite, these transformations in succession just as we did when thinking of them as attachments.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img5.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/9/97/Calc1img5.png",alt:"Calc1img5.png"}})])]),e._v(" "),a("h2",{attrs:{id:"transform-calculus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transform-calculus"}},[e._v("#")]),e._v(" Transform Calculus")]),e._v(" "),a("p",[e._v("This notion of a hierarchy as a chain of transformations taking us from one frame of reference to another is very powerful. In linear algebra, a frame of reference is like a vector "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Basis_%28linear_algebra%29",target:"_blank",rel:"noopener noreferrer"}},[e._v("basis"),a("OutboundLink")],1),e._v("[2], and the transformation to another frame of reference is a "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Change_of_basis",target:"_blank",rel:"noopener noreferrer"}},[e._v("change of basis"),a("OutboundLink")],1),e._v(". In code, we often represent this transformation as a matrix and composite them using matrix multiplication[3]. For efficiency, we sometimes represent a transform using narrower representations like euler angles, quaternions, translations, or even scalars. Regardless of the representation we use, a transformation is essentially a function over a vector space that maps one frame of reference to another. We can represent this function along with operations to manipulate it using a common notation, or calculus:")]),e._v(" "),a("p",[e._v("Transform Calculus Operations")]),e._v(" "),a("p",[e._v("Transformation")]),e._v(" "),a("p",[e._v("TA->B(V)")]),e._v(" "),a("p",[e._v("Evaluating T transforms V from frame A to frame B")]),e._v(" "),a("ul",[a("li",[e._v("Frame A is the â€œinput frameâ€")]),e._v(" "),a("li",[e._v("Frame B is the â€œoutput frameâ€")])]),e._v(" "),a("p",[a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Inverse_function",target:"_blank",rel:"noopener noreferrer"}},[e._v("Inversion"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("TA->B-1 â‡’ TB->A")]),e._v(" "),a("p",[e._v("T-1 reverses the input and output frames, so A->B becomes B->A.")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Composition_of_relations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Composition"),a("OutboundLink")],1),e._v(" (âŠ•)")]),e._v(" "),a("p",[e._v("TA->BâŠ•TB->C â‡’ TA->C")]),e._v(" "),a("p",[e._v("composition forms a â€œchainâ€, going from frame A to frame B to frame C.")]),e._v(" "),a("p",[e._v("Note that composition (âŠ•) is a "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Transitive_relation",target:"_blank",rel:"noopener noreferrer"}},[e._v("transitive relation"),a("OutboundLink")],1),e._v(" -- the output frame of the first must match the input frame of the second, otherwise the composition is invalid:")]),e._v(" "),a("p",[e._v("Composition is Transitive")]),e._v(" "),a("p",[e._v("TA->BâŠ•TB->C")]),e._v(" "),a("p",[e._v("Valid (output Frame B matches input Frame B)")]),e._v(" "),a("p",[e._v("TA->BâŠ•TC->B")]),e._v(" "),a("p",[e._v("Invalid (output Frame B mismatches input Frame C)")]),e._v(" "),a("p",[e._v("TA->BâŠ•TC->B-1 â‡’ TA->BâŠ•TB->C")]),e._v(" "),a("p",[e._v("Valid (inversion swaps the input and output Frame)")]),e._v(" "),a("p",[e._v("Iâ€™m using the mysterious symbol for composition because it is a conceptual operation, and the calculation is not important right now. For instance, something like the multiply or addition operator might seem attractive to use instead, but could be misleading. For instance, two matrices are indeed composited using multiplication, but two translation vectors are composited using addition. However, they are both conceptually a composition of two transformations. I want to convey the concept of composition without focusing on the specific math required to achieve it, which is more tied to the representation used for the transform. Iâ€™ll discuss this more in the next post.")]),e._v(" "),a("p",[e._v("Letâ€™s go back to our rigid body tank example and express some transformations using this new calculus:")]),e._v(" "),a("p",[e._v("Tgun->world = Tgun->turretâŠ•Tturret->chassisâŠ•Tchassis->world")]),e._v(" "),a("p",[e._v("Tgun->wheel1 = Tgun->turretâŠ•Tturret->chassisâŠ•Twheel1->chassis-1")]),e._v(" "),a("p",[e._v("This is makes logical sense: to determine the transformation from the gunâ€™s frame of reference to the worldâ€™s, chain the gun-to-turret transform to the turret-to-chassis transform to the chassis-to-world transform. Each step moves UP the hierarchy to the root. Note in the second example how we use the inverse to go back DOWN the hierarchy to get to the lower wheel1 node, preserving the transitive chain of operations.")]),e._v(" "),a("h2",{attrs:{id:"transforming-vectors-and-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transforming-vectors-and-points"}},[e._v("#")]),e._v(" Transforming Vectors and Points")]),e._v(" "),a("p",[e._v("As discussed, a transformation is a mapping function over the vector space. But we use points to describe geometry. So whatâ€™s the difference between a vector and a point? Well, a point is a distinct location in space, while a vector is a displacement between two points (like a vertex normal). Luckily, both points AND vectors can be represented using "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Homogeneous_coordinates",target:"_blank",rel:"noopener noreferrer"}},[e._v("homogeneous coordinates"),a("OutboundLink")],1),e._v(", the former with a homogeneous coordinate of 1, and the latter with a 0[4]. By thinking of our transforms as operating on "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Affine_space",target:"_blank",rel:"noopener noreferrer"}},[e._v("affine spaces"),a("OutboundLink")],1),e._v(" using homogeneous coordinates, we can transform points and vectors the same way:")]),e._v(" "),a("p",[e._v("TA->B(P) â‡’ Transformation of homogeneous point P from frame A to frame B")]),e._v(" "),a("p",[e._v("TA->B(V) â‡’ Transformation of homogeneous vector V from frame A to frame B")]),e._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[e._v("We have outlined a formal notation, or calculus, for expressing a rigid body hierarchy as a tree of coordinate transformations taking us from the frame of reference of a child node to its parent. We can composite and invert these transformations using a logical notation that allows us to reason about any node from the perspective of any other node, regardless of how that transform is represented. Finally, we can apply these transformations to a set of vectors or points to reason about specific geometry associated with those nodes. This is something Slate has to do all the time.")]),e._v(" "),a("p",[e._v("In the next post Iâ€™ll discuss how these operations are actually implemented using several transformation representations available in UE4 and demonstrate how the calculus allows us to simplify real-world code by expressing the concept rather than focusing on the math itself.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/UE4_Transform_Calculus_-_Part_2",title:"UE4 Transform Calculus - Part 2"}},[e._v("Continue to Part 2 >")])]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"footnotes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#footnotes"}},[e._v("#")]),e._v(" Footnotes")]),e._v(" "),a("p",[e._v("1Iâ€™m applying symbols for particular operations/semantics, so I guess itâ€™s technically a "),a("a",{attrs:{href:"http://www.encyclopediaofmath.org/index.php/Logical_calculus",target:"_blank",rel:"noopener noreferrer"}},[e._v("logico-mathematical calculus"),a("OutboundLink")],1),e._v(", but who really cares?")]),e._v(" "),a("p",[e._v("2 Technically, itâ€™s an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Affine_space",target:"_blank",rel:"noopener noreferrer"}},[e._v("affine space"),a("OutboundLink")],1),e._v(" as we also need an offset to place the basis at a point in space, but the mathematical properties we are concerned with are equivalent, as affine spaces are in fact "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_subspace",target:"_blank",rel:"noopener noreferrer"}},[e._v("vector subspaces"),a("OutboundLink")],1),e._v(". However, studying vector bases leads us more directly to the properties we want to consider.")]),e._v(" "),a("p",[e._v("3This is known as composition of "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_map",target:"_blank",rel:"noopener noreferrer"}},[e._v("linear transformations"),a("OutboundLink")],1),e._v(", which form what is called an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Associative_algebra",target:"_blank",rel:"noopener noreferrer"}},[e._v("associative algebra"),a("OutboundLink")],1),e._v(". This algebra gives us many useful properties like "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Associative_property",target:"_blank",rel:"noopener noreferrer"}},[e._v("associativity"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Distributive_property",target:"_blank",rel:"noopener noreferrer"}},[e._v("distributivity"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("4This "),a("a",{attrs:{href:"http://math.stackexchange.com/questions/89621/how-to-multiply-vector-3-with-4by4-matrix-more-precisely-position-transformat",target:"_blank",rel:"noopener noreferrer"}},[e._v("StackExchange link"),a("OutboundLink")],1),e._v(" gives a good technical explanation without getting too mathy..")]),e._v(" "),a("p",[e._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=UE4_Transform_Calculus_-_Part_1&oldid=14360",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=UE4_Transform_Calculus_-_Part_1&oldid=14360"),a("OutboundLink")],1),e._v('"')]),e._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Epic_Created_Content",title:"Category:Epic Created Content"}},[e._v("Epic Created Content")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=o.exports}}]);