(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{466:function(e,t,n){"use strict";n.r(t);var o=n(28),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Animation Node, Translate With Complete Source Code and Instructions - Epic Wiki")]),e._v(" "),n("h1",{attrs:{id:"animation-node-translate-with-complete-source-code-and-instructions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#animation-node-translate-with-complete-source-code-and-instructions"}},[e._v("#")]),e._v(" Animation Node, Translate With Complete Source Code and Instructions")]),e._v(" "),n("p",[e._v("From Epic Wiki")]),e._v(" "),n("p",[e._v("(Redirected from "),n("a",{attrs:{href:"/index.php?title=Animation_Node,_Translate_With&redirect=no",title:"Animation Node, Translate With"}},[e._v("Animation Node, Translate With")]),e._v(")")]),e._v(" "),n("p",[e._v("Jump to: "),n("a",{attrs:{href:"#mw-navigation"}},[e._v("navigation")]),e._v(", "),n("a",{attrs:{href:"#p-search"}},[e._v("search")])]),e._v(" "),n("h2",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Complete_Code_for_the_Translate_With_Node"}},[e._v("2 Complete Code for the Translate With Node")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Choosing_a_beginning_Class"}},[e._v("3 Choosing a beginning Class")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#AnimNode_TranslateWith"}},[e._v("4 AnimNode_TranslateWith")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#.h"}},[e._v("4.1 .h")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#About_the_Header_.28.h.29_file"}},[e._v("5 About the Header (.h) file")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#.cpp"}},[e._v("5.1 .cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#About_the_Code.28.cpp.29_file"}},[e._v("6 About the Code(.cpp) file")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#About_EvaluateBoneTransforms"}},[e._v("7 About EvaluateBoneTransforms")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#AnimGraphNode_TranslateWith"}},[e._v("8 AnimGraphNode_TranslateWith")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#.h_2"}},[e._v("8.1 .h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#.cpp_2"}},[e._v("8.2 .cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Build.cs_and_YourGame.h_files"}},[e._v("9 Build.cs and YourGame.h files")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Conclusion"}},[e._v("10 Conclusion")])])]),e._v(" "),n("h2",{attrs:{id:"overview"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),n("p",[n("em",[e._v("Original Author")]),e._v(" "),n("a",{attrs:{href:"/index.php?title=User:Chance_07&action=edit&redlink=1",title:"User:Chance 07 (page does not exist)"}},[e._v("Chance_07")])]),e._v(" "),n("p",[n("strong",[e._v("Dear Community")]),e._v(",")]),e._v(" "),n("p",[e._v("In this new tutorial, I will explain the complete process of creating a new Animation Node.")]),e._v(" "),n("p",[e._v("The main purpose for a new tutorial is to help clear up some of the common issue people have been running into when creating nodes for use in Blueprint.")]),e._v(" "),n("p",[e._v("This tutorial will focus on creating a new Skeletal Control Node called Translate With.")]),e._v(" "),n("p",[e._v("A quick primer on the Translate With Node: The node is designed to take a bone (Target) and replicate the movements of another bone (Source) on the specified Axis, with the specified offset. "),n("a",{attrs:{href:"/File:Translatewith.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/2/2f/Translatewith.jpg/1357px-Translatewith.jpg",alt:"Translatewith.jpg"}})])]),e._v(" "),n("h2",{attrs:{id:"complete-code-for-the-translate-with-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#complete-code-for-the-translate-with-node"}},[e._v("#")]),e._v(" Complete Code for the Translate With Node")]),e._v(" "),n("p",[e._v("I will include the complete source code, along with any other needed lines of code to completely integrate the new node into your source. ("),n("em",[e._v("A note on integration, before you begin, you need to determine the scope you wish to use a new node in. For example, if you want to use the node for only one project, you do not need to add the code to the engine source, and can instead add it only to your module. If you plan to use the node across a number of different projects, it may be worth your time to integrate it into your engine, however, this can cause issues if you plan to share the node with others, as they would also have to add the node to the engine in the same manner that you have")]),e._v(")")]),e._v(" "),n("h2",{attrs:{id:"choosing-a-beginning-class"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#choosing-a-beginning-class"}},[e._v("#")]),e._v(" Choosing a beginning Class")]),e._v(" "),n("p",[e._v("In Unreal there are a massive amount of Classes to start with. In general, it is always a good idea to take the time to look through these classes for a couple of reasons. First, by looking through the Classes already in place, you can find the Class that best suits your needs as a base or starting point. Second, it can be extremely helpful to look at the code of other Classes to better understand how to extend these Classes for your needs. If you are unsure of what Class to start from, you can visit "),n("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Programming/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.unrealengine.com/latest/INT/Programming/index.html"),n("OutboundLink")],1),e._v(" for a detailed list of the components included in the Engine.")]),e._v(" "),n("p",[e._v("For this particular project, we will be extending the "),n("strong",[e._v("AnimNode_Base")]),e._v(" class, which you can look through in "),n("strong",[e._v("AnimNodeBase.h")]),e._v(" I am starting with this class because it has the majority of the functionality we will need, but does not include any additional functionality we do not need. In contrast, you can look at "),n("strong",[e._v("AnimNode_SkeletalControl.h")]),e._v(" and see that it already has a few things we will not be using to help you understand this choice better.")]),e._v(" "),n("h2",{attrs:{id:"animnode-translatewith"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#animnode-translatewith"}},[e._v("#")]),e._v(" AnimNode_TranslateWith")]),e._v(" "),n("h3",{attrs:{id:"h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#h"}},[e._v("#")]),e._v(" .h")]),e._v(" "),n("p",[e._v('// Created by Chance_07 2014\n#pragma once\nÂ \n#include "AnimNode_TranslateWith.generated.h"\nÂ \nUSTRUCT()\nstruct FAnimNode_TranslateWith : public  FAnimNode_Base\n{\nGENERATED_USTRUCT_BODY()\nÂ \n/** Input link(Base Pose) **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Links)\nFComponentSpacePoseLink ComponentPose;\nÂ \n/** Name of bone to control **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\nFBoneReference TargetBone;\nÂ \n/** Source Bone Name to get transform from **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\nFBoneReference SourceBone;\nÂ \n/** This is typically the FORWARD Axis, and is false by default **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\nbool bUpdateX;\nÂ \n/** This is typically the SIDE-TO-SIDE Axis, and is false by default **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\nbool bUpdateY;\nÂ \n/** This is typically the UP Axis, and is true by default **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AxisLock, meta = (PinHiddenByDefault))\nbool bUpdateZ;\nÂ \n/** Target Location in world space if LookAtBone is empty */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl)\nFVector AddtoOffset;\nÂ \n/** Controls how much of the translation is blended to the target, default is 1 **/\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SkeletalControl, meta = (PinShownByDefault))\nfloat BlendWeight;\npublic:\nFAnimNode_TranslateWith();\npublic:\n// FAnimNode_Base interface\nvirtual void Initialize(const FAnimationInitializeContext& Context) OVERRIDE;\nvirtual void CacheBones(const FAnimationCacheBonesContext & Context)  OVERRIDE;\nvirtual void Update(const FAnimationUpdateContext& Context) OVERRIDE;\nvirtual void EvaluateComponentSpace(FComponentSpacePoseContext& Output) OVERRIDE;\n// End of FAnimNode_RCAnimNode interface\nprotected:\n// initialize any bone references you have\nvirtual void InitializeBoneReferences(const FBoneContainer & RequiredBones);\n// return true if it is valid to Evaluate\nvirtual bool IsValidToEvaluate(const USkeleton * Skeleton, const FBoneContainer & RequiredBones);\n// Evaluate the new component-space transforms for the affected bones.\nvirtual void EvaluateBoneTransforms(USkeletalMeshComponent* SkelComp, const FBoneContainer & RequiredBones, FA2CSPose& MeshBases, TArray<FBoneTransform>& OutBoneTransforms);// {}\nprivate:\nFVector ModTargetLocationInCompSpace;\nFVector CurrentAddedOffset;\nFVector JointOffset;\n};')]),e._v(" "),n("h2",{attrs:{id:"about-the-header-h-file"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#about-the-header-h-file"}},[e._v("#")]),e._v(" About the Header (.h) file")]),e._v(" "),n("p",[e._v("Lets take a quick look at this header file. At the top we have an include file. AnimNode_TranslateWith.generated.h is created by UBT. You do not need to create or edit this file, but should always be included with your code.")]),e._v(" "),n("p",[e._v("Next, we have our USTRUCT() declaration which tells Unreal what this section has, and what Class we are pulling from (in this case, FAnimNode_Base).")]),e._v(" "),n("p",[e._v("After the main declaration, we have a few more that come in the form of UPROPRETY. The first one, ComponentPose, is going to be used as the input for our node when added to an Animation Blueprint.")]),e._v(" "),n("p",[e._v("The next two are our Target Bone, and our Source Bone. The Target Bone is the bone we will be applying all of our transformations to, while the Source Bone is the bone we will be pulling information from.")]),e._v(" "),n("p",[e._v("Next we have the Constructor (FAnimNode_TranslateWith()ðŸ˜‰")]),e._v(" "),n("p",[e._v("After the Constructor, we have some functions. Notice that the first four have the word OVERRIDE at the end. This simply means that the parent class also has these functions, but we wish to modify them in our .cpp file.")]),e._v(" "),n("p",[e._v("The last two parts of our header have a few added functions, and a few variables. Notice that the variables are set to private. In this instance, I have no intention of letting any other nodes, or code have access to these, and therefor they are private.")]),e._v(" "),n("h3",{attrs:{id:"cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cpp"}},[e._v("#")]),e._v(" .cpp")]),e._v(" "),n("p",[e._v('// Created by Chance_07 2014\nÂ \n#include "YourGame.h"\n#include "EnginePrivate.h"\n#include "AnimNode_TranslateWith.h"\nÂ \nFAnimNode_TranslateWith::FAnimNode_TranslateWith()\n: FAnimNode_Base()\n, bUpdateX(false)// This is only to set\n, bUpdateY(false)// the defaults for the\n, bUpdateZ(true)// Axis pins (Can be changed in BP)\n, AddtoOffset(FVector::ZeroVector)\n{\nBlendWeight = 1;\nJointOffset.ZeroVector;\n// NULL so that it will be tested at least once\nCurrentAddedOffset.X = NULL;\nCurrentAddedOffset.Y = NULL;\nCurrentAddedOffset.Z = NULL;\n}\nÂ \nvoid FAnimNode_TranslateWith::Initialize(const FAnimationInitializeContext& Context)\n{\nComponentPose.Initialize(Context);\n}\nÂ \nvoid FAnimNode_TranslateWith::Update(const FAnimationUpdateContext& Context)\n{\nComponentPose.Update(Context);\n}\nÂ \nvoid FAnimNode_TranslateWith::CacheBones(const FAnimationCacheBonesContext & Context)\n{\nInitializeBoneReferences(Context.AnimInstance->RequiredBones);\nComponentPose.CacheBones(Context);\n}\nÂ \n//This is just a check to make sure that the bones are present\nvoid FAnimNode_TranslateWith::InitializeBoneReferences(const FBoneContainer & RequiredBones)\n{\n// Check the Source Bone\nif (SourceBone.Initialize(RequiredBones)){}\nelse\n{\nUE_LOG(LogAnimation, Warning, TEXT("No Source Bone found, please check input"));\n}\nÂ \n// Check the Target Bone\nif (TargetBone.Initialize(RequiredBones)){}\nelse\n{\nUE_LOG(LogAnimation, Warning, TEXT("No Target Bone found, please check input"));\n}\n}\nÂ \n//This Checks for Updates, if no Axis is checked, returns Base Pose and moves on\nvoid FAnimNode_TranslateWith::EvaluateComponentSpace(FComponentSpacePoseContext& Output)\n{\n// Evaluate the input\nComponentPose.EvaluateComponentSpace(Output);\nÂ \nÂ \n// If any Axis is checked, and both bones are present, then we will continue\nif (((bUpdateX) || (bUpdateY) || (bUpdateZ)) && IsValidToEvaluate(Output.AnimInstance->CurrentSkeleton, Output.AnimInstance->RequiredBones))\n{\nUSkeletalMeshComponent* Component = Output.AnimInstance->GetSkelMeshComponent();\nTArray<FBoneTransform> BoneTransforms;\nEvaluateBoneTransforms(Component, Output.AnimInstance->RequiredBones, Output.Pose, BoneTransforms);\nÂ \ncheckSlow(!ContainsNaN(BoneTransforms));\nÂ \nif (BoneTransforms.Num() > 0)\n{\nOutput.Pose.LocalBlendCSBoneTransforms(BoneTransforms, BlendWeight);\n}\n}\n}\nÂ \n//This Evaluates the bones, and transforms\nvoid FAnimNode_TranslateWith::EvaluateBoneTransforms(USkeletalMeshComponent* SkelComp, const FBoneContainer & RequiredBones, FA2CSPose& MeshBases, TArray<FBoneTransform>& OutBoneTransforms)\n{\ncheck(OutBoneTransforms.Num() == 0);\nÂ \n// Component Space Transforms used to modify Target Bone\nFTransform SourceBoneTM = MeshBases.GetComponentSpaceTransform(SourceBone.BoneIndex);\nFTransform TargetBoneTM = MeshBases.GetComponentSpaceTransform(TargetBone.BoneIndex);\nÂ \n// If any changes have occured, add them, and reset offset\nif (!(CurrentAddedOffset == AddtoOffset))\n{\nCurrentAddedOffset = SkelComp->ComponentToWorld.InverseTransformPosition(AddtoOffset);\nJointOffset.Set((NULL),(NULL),(NULL));\n}\nÂ \nif ( (JointOffset.X == NULL) || (JointOffset.Y == NULL) || (JointOffset.Z == NULL))// If no Axis are checked, no need to do anything\n{\n// These are based on the Base Pose location and used to create the default offset\nFVector tempSourceOffset;\nFVector tempTargetOffset;\nÂ \n// Get the Base Pose of the Source Bone\ntempSourceOffset.Set((SourceBoneTM.GetLocation().X), (SourceBoneTM.GetLocation().Y), (SourceBoneTM.GetLocation().Z));\nÂ \n// Get the Base Pose of the Target Bone\ntempTargetOffset.Set((TargetBoneTM.GetLocation().X), (TargetBoneTM.GetLocation().Y), (TargetBoneTM.GetLocation().Z));\nÂ \n// Get the Starting Offset from ALL inputs\nJointOffset.Set((tempTargetOffset.X-tempSourceOffset.X+CurrentAddedOffset.X),(tempTargetOffset.Y-tempSourceOffset.Y+CurrentAddedOffset.Y),(tempTargetOffset.Z-tempSourceOffset.Z+CurrentAddedOffset.Z));\nÂ \n// Assign Offset to Mod Target Location\nModTargetLocationInCompSpace.Set((tempTargetOffset.X), (tempTargetOffset.Y), (tempTargetOffset.Z));\nÂ \nÂ \n}\n//need to add a multiplier control so that you can control how much of the source movement is translated to the target(I.E. BlendEffects)\nif (bUpdateX)//Update X if checked\n{\t\t\nModTargetLocationInCompSpace.X = ((SourceBoneTM.GetTranslation().X)+ JointOffset.X);//SourceTM + Offset\n}\nif (bUpdateY)//Update Y if checked\n{\nModTargetLocationInCompSpace.Y = ((SourceBoneTM.GetTranslation().Y) + JointOffset.Y);\n}\nif (bUpdateZ)//Update Z if checked\n{\t\nModTargetLocationInCompSpace.Z = ((SourceBoneTM.GetTranslation().Z) + JointOffset.Z); //(SourceBoneTM.GetTranslation().Z);\n}\n//Set the Targets Transform and pass out to Output(End of tick)\nTargetBoneTM.SetTranslation(ModTargetLocationInCompSpace);\nÂ \n// Returns to caller with new location\nOutBoneTransforms.Add(FBoneTransform(TargetBone.BoneIndex, TargetBoneTM));\t\n}\nÂ \n// Makes sure that both bones are valid\nbool FAnimNode_TranslateWith::IsValidToEvaluate(const USkeleton * Skeleton, const FBoneContainer & RequiredBones)\n{\n// if both bones are valid\nreturn (TargetBone.IsValid(RequiredBones) && (SourceBone.IsValid(RequiredBones)));\n}')]),e._v(" "),n("h2",{attrs:{id:"about-the-code-cpp-file"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#about-the-code-cpp-file"}},[e._v("#")]),e._v(" About the Code(.cpp) file")]),e._v(" "),n("p",[e._v("Lets take a look at the code file now.")]),e._v(" "),n("p",[e._v('Again we start off with a couple of include files. One thing to note here, is that the first include file should always be the header file for your module. In this case, "YourGame.h". We also need to make sure that we include the AnimNode_TranslateWith.h file, otherwise our code will not know which header to use.')]),e._v(" "),n("p",[e._v("After the includes, we have some defaults. This section is generally up to the user, but it does outline the starting point of the node. For this example, we have set the Z-Axis to true, and the other Axis' to false. We also declare a starting point for our BlendWeight, and clear out our CurrentAddedOffset (which I will explain soon).")]),e._v(" "),n("p",[e._v("Next we have some functions. First we will Initialize the input (ComponentPose). Next we call Update. After Update, we call the CacheBones function. This does two things. First, it calls the InitializeBoneReferences function. After that has run, we cache the ComponentPose.")]),e._v(" "),n("p",[e._v("The InitializeBoneReferences works the same as our Initialize from earlier, except that it focuses on our Target and Source bones. If for whatever reason, it cannot find one of these two, we will print an error message to the Output Log. This can be helpful for troubleshooting issues.")]),e._v(" "),n("p",[e._v("After InitializeBoneReferences, we have EvaluateComponentSpace. This takes our input pose, and evaluates it. After that, it checks a couple things. First, we test to see if at least one Axis is selected for update. If no Axis has been selected, there is no need to go any farther. After we check the Axis selection, and if one is selected, we then check that the bones in Target and Source are valid bones to be evaluated. If both bones are, then we will continue.")]),e._v(" "),n("p",[e._v("If everything has checked out good to this point, we will create a couple variables, and then call EvaluateBoneTransforms.")]),e._v(" "),n("p",[e._v("After EvaluateBoneTransforms has finished, we come back here and run checkSlow on our BoneTransforms.")]),e._v(" "),n("p",[e._v("Finally, we send the output to the next node in the Animation Blueprint.")]),e._v(" "),n("h2",{attrs:{id:"about-evaluatebonetransforms"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#about-evaluatebonetransforms"}},[e._v("#")]),e._v(" About EvaluateBoneTransforms")]),e._v(" "),n("p",[e._v('This is the "meat" of our node. First we will check our OutBoneTransforms array. Next we create two FTransform variables, and assign them to our Source bone, and Target bone. Next, we check our CurrentAddedOffset to see if it equals AddtoOffset. If you remember, earlier we set CurrentAddedOffset to NULL. This is why. The first time this runs, when we test the CurrentAddedOffset == AddtoOffset, it always come back as false which will in turn, run the following code. From that point on, if nothing changes, it will not have a need to update this part. After we have assigned CrrentAddedOffset a value, we clear JointOffset. This again is strictly to update only if we have to.')]),e._v(" "),n("p",[e._v("We check JointOffset for NULL values, and if any return we will run the following section. We create two FVectors, assign them each a value, run some simple math operations and then assign them to JointOffset. We also assign the Target bones location to ModTargetLocationInCompSpace, which simply holds the starting location in Component Space.")]),e._v(" "),n("p",[e._v("Next, we check each Axis one at a time, and if an Axis is selected, we change ModTargetLocationInCompSpace accordingly (this will be used to update our Target bone).")]),e._v(" "),n("p",[e._v("Finally, we input or new location to our Target bone transform, and return the new value to our OutBoneTransform.")]),e._v(" "),n("h2",{attrs:{id:"animgraphnode-translatewith"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#animgraphnode-translatewith"}},[e._v("#")]),e._v(" AnimGraphNode_TranslateWith")]),e._v(" "),n("p",[e._v("So now what? We have our code in place, maybe we have compiled and run the Editor, but no node. We still have two files left to add. These are the AnimGraphNode files and they hold the code that creates the visual representation of our node.")]),e._v(" "),n("h3",{attrs:{id:"h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#h-2"}},[e._v("#")]),e._v(" .h")]),e._v(" "),n("p",[e._v('// Created by Chance_07 2014\n#pragma once\nÂ \n#include "AnimGraphNode_Base.h"\n#include "AnimNode_TranslateWith.h"\n#include "AnimGraphNode_TranslateWith.generated.h"\nÂ \n/**\n*\n*/\nUCLASS(MinimalAPI, dependson = AnimNode_TranslateWith)\nclass UAnimGraphNode_TranslateWith : public UAnimGraphNode_Base\n{\nGENERATED_UCLASS_BODY()\nÂ \nUPROPERTY(EditAnywhere, Category = SkeletalControl)\nFAnimNode_TranslateWith Node;\nÂ \npublic:\n// UEdGraphNode interface\nvirtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const OVERRIDE;\nvirtual FString GetTooltip() const OVERRIDE;\nvirtual FString GetNodeCategory() const OVERRIDE;\nvirtual FLinearColor GetNodeTitleColor() const OVERRIDE;\nvirtual void CreateOutputPins() OVERRIDE;\n// End of UEdGraphNode interface\nÂ \nprotected:\nvirtual FText GetControllerDescription() const ;\nÂ \n};')]),e._v(" "),n("p",[e._v("AnimGraphNode_TranslateWith.h contains the same format as our previous header file. We have our include files, our declarations, and our OVERRIDE. You should notice, we do have one UPROPRETY in here where we declare a variable using the Category = SkeletalControl. This is where in the context menu our node will appear.")]),e._v(" "),n("h3",{attrs:{id:"cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cpp-2"}},[e._v("#")]),e._v(" .cpp")]),e._v(" "),n("p",[e._v('// Created by Chance_07 2014\nÂ \n#include "YourGame.h"\n#include "Editor/AnimGraph/Private/AnimGraphPrivatePCH.h"\n#include "AnimationGraphSchema.h"\n#include "AnimGraphNode_TranslateWith.h"\nÂ \n#define LOCTEXT_NAMESPACE "AnimGraph_TranslateWith"\nÂ \nUAnimGraphNode_TranslateWith::UAnimGraphNode_TranslateWith(const FPostConstructInitializeProperties& PCIP)\n: Super(PCIP)\n{\n}\nÂ \n//Title Color!\nFLinearColor UAnimGraphNode_TranslateWith::GetNodeTitleColor() const\n{\nreturn FLinearColor(0.75f, 0.75f, 0.10f);\n}\nÂ \n//Node Category\nFString UAnimGraphNode_TranslateWith::GetNodeCategory() const\n{\nreturn FString("Skeletal Controls");\n}\nFText UAnimGraphNode_TranslateWith::GetControllerDescription() const\n{\nreturn LOCTEXT("TranslateWithNode", "Translate With");\n}\nÂ \nÂ \n//Node Tooltip\nFString UAnimGraphNode_TranslateWith::GetTooltip() const\n{\nreturn TEXT("The Translate WIth control allows the Target Bone to follow the Translation of the Source Bone on all Specified Axis");\n}\nÂ \n//Node Title(Needs to be updated now since node is much more versatile)\nFText UAnimGraphNode_TranslateWith::GetNodeTitle(ENodeTitleType::Type TitleType) const\n{\nÂ \nFFormatNamedArguments Args;\nArgs.Add(TEXT("ControllerDescription"), GetControllerDescription());\nÂ \nÂ \nif (TitleType == ENodeTitleType::ListView)\n{\nreturn FText::Format(LOCTEXT("AnimGraphNode_TranslateWith_Title", "{ControllerDescription}"), Args);\n}\nelse\n{\nArgs.Add(TEXT("SourceBoneName"), FText::FromName(Node.SourceBone.BoneName));\nArgs.Add(TEXT("TargetBoneName"), FText::FromName(Node.TargetBone.BoneName));\nreturn FText::Format(LOCTEXT("AnimGraphNode_TranslateWith_Title", "{ControllerDescription}\\nSource Bone: {SourceBoneName}\\nTarget Bone: {TargetBoneName}"), Args);\n}\nÂ \n}\nÂ \n//Node Output Pin(Output is in Component Space, Change at own RISK!)\nvoid UAnimGraphNode_TranslateWith::CreateOutputPins()\n{\nconst UAnimationGraphSchema* Schema = GetDefault<UAnimationGraphSchema>();\nCreatePin(EGPD_Output, Schema->PC_Struct, TEXT(""), FComponentSpacePoseLink::StaticStruct(), /*bIsArray=*/ false, /*bIsReference=*/ false, TEXT("Pose"));\n}\nÂ \n#undef LOCTEXT_NAMESPACE')]),e._v(" "),n("p",[e._v("AnimGraphNode_TranslateWith.cpp again contains the functions we will be running. The one part I would like to draw your attention to is the CreateOutputPins function. As you can see, it is marked as Change at own RISK, and for very good reason. This output is designed to run in ComponentSpace, and if for some reason, that changes, it can cause instability issues in the Editor. I recommend, at least until you are very familiar with the Engine, that you do not change this.")]),e._v(" "),n("h2",{attrs:{id:"build-cs-and-yourgame-h-files"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#build-cs-and-yourgame-h-files"}},[e._v("#")]),e._v(" Build.cs and YourGame.h files")]),e._v(" "),n("p",[e._v("Depending on the Engine version you are using, this may change some but I will cover the basics. YourGame.h contains a list of include files that your module or game needs access to, so be sure to check that you have included anything you need to here. This can change greatly based on your project, but always try to only include files you have to. There is no need to include files you already have access to.")]),e._v(" "),n("p",[e._v("An example here would be:")]),e._v(" "),n("p",[e._v('#include "BlueprintUtilities.h"')]),e._v(" "),n("p",[e._v("Build.cs again can change greatly based on your project, but a couple lines that will help get you started:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    PublicDependencyModuleNames.AddRange(new string\\[\\] { "Core", "CoreUObject", "Engine", "AnimGraph" });\n')])])]),n("p",[e._v('PrivateDependencyModuleNames.AddRange(new string[] { "InputCore", "HTTP", "AnimGraph", "BlueprintGraph", "UnrealEd" });')]),e._v(" "),n("p",[e._v("These are basically just paths to different locations within the engine.")]),e._v(" "),n("h2",{attrs:{id:"conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),n("p",[e._v("At this point, you should be able to compile the Engine and run your game. Create a new Animation Blueprint (or open existing one), right click and look under Skeletal Controls. You should see Translate With as an available node now.")]),e._v(" "),n("p",[e._v("Congratulations! You created a new animation node.")]),e._v(" "),n("p",[n("a",{attrs:{href:"/index.php?title=User:Chance_07&action=edit&redlink=1",title:"User:Chance 07 (page does not exist)"}},[e._v("Chance_07")])]),e._v(" "),n("p",[e._v('Retrieved from "'),n("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Animation_Node,_Translate_With_Complete_Source_Code_and_Instructions&oldid=6287",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Animation_Node,_Translate_With_Complete_Source_Code_and_Instructions&oldid=6287"),n("OutboundLink")],1),e._v('"')]),e._v(" "),n("p",[n("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);