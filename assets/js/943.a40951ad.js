(window.webpackJsonp=window.webpackJsonp||[]).push([[943],{259:function(e,t,n){"use strict";n.r(t);var o=n(28),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Rama's Vertex Snap Editor Plugin - Epic Wiki")]),e._v(" "),n("h1",{attrs:{id:"rama-s-vertex-snap-editor-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rama-s-vertex-snap-editor-plugin"}},[e._v("#")]),e._v(" Rama's Vertex Snap Editor Plugin")]),e._v(" "),n("h2",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Entire_C.2B.2B_Source_Code"}},[e._v("1.1 Entire C++ Source Code")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Pictures"}},[e._v("2 Pictures")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Plugin_Release_Dates_and_UE4_Engine_Versions"}},[e._v("3 Plugin Release Dates and UE4 Engine Versions")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#All_Future_Updates"}},[e._v("4 All Future Updates")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#4.11"}},[e._v("4.1 4.11")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#4.10"}},[e._v("4.2 4.10")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#4.9.2"}},[e._v("4.3 4.9.2")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Plugin_Download"}},[e._v("5 Plugin Download")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Victory_BP_Library_.7E_100.2B_Extra_Blueprint_Nodes"}},[e._v("5.1 Victory BP Library ~ 100+ Extra Blueprint Nodes")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Victory_Ed_Engine_.7E_Vertex_Snapping_.26_Instanced_Static_Mesh_Editor"}},[e._v("5.2 Victory Ed Engine ~ Vertex Snapping & Instanced Static Mesh Editor")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Installation_of_Victory_Blueprint_Library"}},[e._v("6 Installation of Victory Blueprint Library")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Installation_of_VictoryEdEngine_for_Vertex_Snapping"}},[e._v("7 Installation of VictoryEdEngine for Vertex Snapping")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Disabling_My_Editor_Mode_.2F_Entire_Plugin"}},[e._v("7.1 Disabling My Editor Mode / Entire Plugin")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Instanced_Static_Mesh_Editor"}},[e._v("8 Instanced Static Mesh Editor")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Update:_Part_of_Victory_Ed_Engine"}},[e._v("8.1 Update: Part of Victory Ed Engine")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Mandatory_Setup_Step"}},[e._v("8.2 Mandatory Setup Step")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Works_With_UE4_Undo_System"}},[e._v("9 Works With UE4 Undo System")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Newest_Editor_Feature:"}},[e._v("10 Newest Editor Feature:")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#New_Display_Options"}},[e._v("10.1 New Display Options")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#New_Workflow.283.2F27.2F14.29"}},[e._v("10.2 New Workflow(3/27/14)")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#New_Snap_to_Surface_Normal_Workflow"}},[e._v("10.3 New Snap to Surface Normal Workflow")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Drop_Static_Meshes_to_Nearest_Surface.21"}},[e._v("11 Drop Static Meshes to Nearest Surface!")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Vertex_Snap_Plugin"}},[e._v("12 Vertex Snap Plugin")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#UE4_Editor_Plugin.2C_No_Code_Compile_Required"}},[e._v("12.1 UE4 Editor Plugin, No Code Compile Required")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Victory_Editor_Align_Mode"}},[e._v("13 Victory Editor Align Mode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Features:"}},[e._v("13.1 Features:")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Instant_Mouse_Move_of_Static_Mesh_Actor"}},[e._v("13.1.1 Instant Mouse Move of Static Mesh Actor")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Reset_any_Static_Mesh_Actor.27s_rotation_to_0"}},[e._v("13.1.2 Reset any Static Mesh Actor's rotation to 0")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Vertx_Display_and_Snapping"}},[e._v("13.1.3 Vertx Display and Snapping")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Vertex_Resizing"}},[e._v("13.1.4 Vertex Resizing")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Verticies_Dynamically_Update"}},[e._v("13.1.5 Verticies Dynamically Update")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Vertex_Selection"}},[e._v("13.1.6 Vertex Selection")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#WorkFlow_Efficiency"}},[e._v("13.2 WorkFlow Efficiency")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Fast_User_Interface"}},[e._v("13.2.1 Fast User Interface")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Speed:_Using_the_PDI_.2F_Primitive_Draw_Interface"}},[e._v("13.2.2 Speed: Using the PDI / Primitive Draw Interface")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#High_Vertex_Counts"}},[e._v("13.2.3 High Vertex Counts")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Editor_Environment_Integration"}},[e._v("13.2.4 Editor Environment Integration")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Using_Vertex_Snap_Mode"}},[e._v("13.3 Using Vertex Snap Mode")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Vertex_Editor_Plugin_Summary"}},[e._v("13.4 Vertex Editor Plugin Summary")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#"}},[e._v("14")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#My_Entire_Plugin_C.2B.2B_Source_Code"}},[e._v("15 My Entire Plugin C++ Source Code")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Credits"}},[e._v("15.1 Credits")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#VictoryEdEngine"}},[e._v("15.2 VictoryEdEngine")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#.H"}},[e._v("15.2.1 .H")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#.CPP"}},[e._v("15.2.2 .CPP")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#VictoryEdMode"}},[e._v("15.3 VictoryEdMode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#.H_2"}},[e._v("15.3.1 .H")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#.CPP_2"}},[e._v("15.3.2 .CPP")])])])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#_2"}},[e._v("16")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Core_of_Making_Your_Own_Editor_Mode"}},[e._v("17 Core of Making Your Own Editor Mode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Interaction_of_EdEngine_with_EdMode_Class"}},[e._v("17.1 Interaction of EdEngine with EdMode Class")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Activating_The_Editor_Mode.2C_Once_Created"}},[e._v("17.2 Activating The Editor Mode, Once Created")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#The_Ed_Mode.27s_Unique_ID"}},[e._v("17.3 The Ed Mode's Unique ID")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Plugin_Build.cs"}},[e._v("18 Plugin Build.cs")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Plugin_Download_2"}},[e._v("19 Plugin Download")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Enjoy.21"}},[e._v("20 Enjoy!")])])]),e._v(" "),n("h2",{attrs:{id:"overview"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),n("p",[n("em",[e._v("Plugin Author:")]),e._v(" "),n("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[e._v("Rama")]),e._v(" ("),n("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[e._v("talk")]),e._v(")")]),e._v(" "),n("p",[e._v("Dear Community,")]),e._v(" "),n("p",[e._v("Here is my Vertex Snapping UE4 Editor Plugin!")]),e._v(" "),n("p",[e._v("Below I am sharing with you not only the actual plugin, but the "),n("strong",[e._v("entire source code for")]),e._v(":")]),e._v(" "),n("p",[e._v("1. The plugin, showing you how to make your own (you get the source with my plugin file download)")]),e._v(" "),n("p",[e._v("2. My extended UE4 Editor Engine class")]),e._v(" "),n("p",[e._v("3. My very own Vertex Snapping Editor Mode, showing you via complete example how you can make your own Editor Modes!")]),e._v(" "),n("h3",{attrs:{id:"entire-c-source-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#entire-c-source-code"}},[e._v("#")]),e._v(" Entire C++ Source Code")]),e._v(" "),n("p",[n("a",{attrs:{href:"#My_Entire_Plugin_C.2B.2B_Source_Code"}},[e._v("My Entire C++ Source Code For You!")])]),e._v(" "),n("h2",{attrs:{id:"pictures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pictures"}},[e._v("#")]),e._v(" Pictures")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:InstancedStaticMeshEditor.jpg",title:"800x"}},[n("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/b/b2/InstancedStaticMeshEditor.jpg",alt:"800x"}})])]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VertexSnapContinuous.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/8/8d/VertexSnapContinuous.jpg/486px-VertexSnapContinuous.jpg",alt:"VertexSnapContinuous.jpg"}})])]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VertexEditorPlugin_Snap.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/3/38/VertexEditorPlugin_Snap.jpg/600px-VertexEditorPlugin_Snap.jpg",alt:"VertexEditorPlugin Snap.jpg"}})])]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VertexEditorPlugin_Resize.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/b/bf/VertexEditorPlugin_Resize.jpg/600px-VertexEditorPlugin_Resize.jpg",alt:"VertexEditorPlugin Resize.jpg"}})])]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VertexEditorPlugin_SnapAngle.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/f/fc/VertexEditorPlugin_SnapAngle.jpg/600px-VertexEditorPlugin_SnapAngle.jpg",alt:"VertexEditorPlugin SnapAngle.jpg"}})])]),e._v(" "),n("h2",{attrs:{id:"plugin-release-dates-and-ue4-engine-versions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#plugin-release-dates-and-ue4-engine-versions"}},[e._v("#")]),e._v(" Plugin Release Dates and UE4 Engine Versions")]),e._v(" "),n("h2",{attrs:{id:"all-future-updates"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#all-future-updates"}},[e._v("#")]),e._v(" All Future Updates")]),e._v(" "),n("p",[e._v("Because of the wiki file size limit of 20mb I am compelled to unify my Victory Plugin distribution into Editor + Packaged Binaries only in a media fire download from now on.")]),e._v(" "),n("p",[e._v("All future updates are at this link:")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.mediafire.com/?ieovbd5l9d7yub2",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rama's Victory Plugin, Editor + Packaged Binaries"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Entire C++ Source code is included!")]),e._v(" "),n("p",[n("strong",[e._v("Github link:")]),e._v(" "),n("a",{attrs:{href:"https://github.com/EverNewJoy/VictoryPlugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/EverNewJoy/VictoryPlugin"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"_4-11"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-11"}},[e._v("#")]),e._v(" 4.11")]),e._v(" "),n("p",[e._v("4.11 is the current engine version of my Victory Plugin, beginning with the February 15th build!")]),e._v(" "),n("p",[e._v("Please note that due to wiki file size limits (20mb), starting with 4.11 Victory Packaged Binaries only contains Development Win64.")]),e._v(" "),n("p",[e._v("If you need to package for a build other than Development Win64 you will need to install visual studio 2015 and compile the source code that I freely provide with every build.")]),e._v(" "),n("h3",{attrs:{id:"_4-10"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-10"}},[e._v("#")]),e._v(" 4.10")]),e._v(" "),n("p",[e._v("The last 4.10 updates of my plugins:")]),e._v(" "),n("p",[e._v("February 6th, 2016")]),e._v(" "),n("h3",{attrs:{id:"_4-9-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-2"}},[e._v("#")]),e._v(" 4.9.2")]),e._v(" "),n("p",[e._v("The last 4.9.2 updates for my plugins:")]),e._v(" "),n("p",[n("strong",[e._v("Victory BP Library")]),e._v(" ~ October 14th, 2015")]),e._v(" "),n("p",[n("strong",[e._v("Victory BP Library Packaged Binaries")]),e._v(" ~ October 14th, 2015")]),e._v(" "),n("p",[n("strong",[e._v("Victory Ed Engine(Vertex Snap and ISM Editor)")]),e._v(" ~ October 25th, 2015")]),e._v(" "),n("h2",{attrs:{id:"plugin-download"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#plugin-download"}},[e._v("#")]),e._v(" Plugin Download")]),e._v(" "),n("p",[e._v("(Please note these files do not contain an executable, just the .dll that UE4 needs for a plugin, that's why the file warning appears)")]),e._v(" "),n("h3",{attrs:{id:"victory-bp-library-100-extra-blueprint-nodes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#victory-bp-library-100-extra-blueprint-nodes"}},[e._v("#")]),e._v(" Victory BP Library ~ 100+ Extra Blueprint Nodes")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VictoryPlugin.zip",title:"File:VictoryPlugin.zip"}},[e._v("File:VictoryPlugin.zip")])]),e._v(" "),n("p",[e._v("If you want to "),n("strong",[e._v("package")]),e._v(" my plugin for "),n("strong",[e._v("Win32 Shipping")]),e._v(" or "),n("strong",[e._v("Win64 Development")]),e._v(" you can merge these binaries with the main plugin installation above!")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VictoryPluginPackaged.zip",title:"File:VictoryPluginPackaged.zip"}},[e._v("File:VictoryPluginPackaged.zip")])]),e._v(" "),n("h3",{attrs:{id:"victory-ed-engine-vertex-snapping-instanced-static-mesh-editor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#victory-ed-engine-vertex-snapping-instanced-static-mesh-editor"}},[e._v("#")]),e._v(" Victory Ed Engine ~ Vertex Snapping & Instanced Static Mesh Editor")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VictoryEdEngine.zip",title:"File:VictoryEdEngine.zip"}},[e._v("File:VictoryEdEngine.zip")])]),e._v(" "),n("h2",{attrs:{id:"installation-of-victory-blueprint-library"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#installation-of-victory-blueprint-library"}},[e._v("#")]),e._v(" Installation of Victory Blueprint Library")]),e._v(" "),n("p",[e._v("You should install my Victory Plugin in the Engine/Plugins/Runtime folder of the appropriate Engine version.")]),e._v(" "),n("p",[e._v("You should always try to package for Development Win64 first, and Shipping Win32 as these are the only two platforms I support for those who do not have C++ access.")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://forums.unrealengine.com/showthread.php?3851-(39)-Rama-s-Extra-Blueprint-Nodes-for-You-as-a-Plugin-No-C-Required!&p=476476&viewfull=1#post476476",target:"_blank",rel:"noopener noreferrer"}},[e._v("Detailed Description"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"installation-of-victoryedengine-for-vertex-snapping"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#installation-of-victoryedengine-for-vertex-snapping"}},[e._v("#")]),e._v(" Installation of VictoryEdEngine for Vertex Snapping")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:Victorybpplugin.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/0/0b/Victorybpplugin.jpg/650px-Victorybpplugin.jpg",alt:"Victorybpplugin.jpg"}})])]),e._v(" "),n("p",[e._v("Plugin download ("),n("strong",[e._v("5.8 MB")]),e._v("):")]),e._v(" "),n("p",[e._v("It is important to do all of these steps in order")]),e._v(" "),n("p",[e._v('1. download my editor / BP plugin and put in a directory directly off of your main project directory called "'),n("strong",[e._v("Plugins")]),e._v('"')]),e._v(" "),n("p",[e._v("spelling must be exact")]),e._v(" "),n("p",[e._v("2. Load UE4 editor and go to Windows->Plugins")]),e._v(" "),n("p",[e._v("3. Find my plugin and make sure it is checked as being active")]),e._v(" "),n("p",[e._v("4. maybe double check #3")]),e._v(" "),n("p",[e._v("5. close the editor.")]),e._v(" "),n("p",[e._v("6. go to "),n("strong",[e._v("YourProject/Config/DefaultEngine.ini")])]),e._v(" "),n("p",[e._v("7. add these lines:")]),e._v(" "),n("p",[e._v("[/Script/Engine.Engine]\nUnrealEdEngine=/Script/VictoryEdEngine.VictoryEdEngine")]),e._v(" "),n("p",[e._v("8. Load UE4 Editor again")]),e._v(" "),n("p",[e._v("9. click on any static mesh actor")]),e._v(" "),n("p",[e._v("10. You should now see the Victory Editor HotKeys button in the top left")]),e._v(" "),n("p",[e._v("11. If you hover mouse over this title area any time, you can get the list of hotkeys")]),e._v(" "),n("p",[e._v("12. Enjoooy!")]),e._v(" "),n("p",[n("strong",[e._v("What does this all do?")])]),e._v(" "),n("p",[e._v("My plugin includes an alternative UnrealEdEngine class, that makes use of my new additional FEdMode editor mode class.")]),e._v(" "),n("p",[e._v("The config file tells the main UE4 binary to use my alternative UnrealEdEngine class instead of the default.")]),e._v(" "),n("p",[e._v("Commenting out the line you added will instantly disable my Editor Mode.")]),e._v(" "),n("p",[e._v("Unchecking my plugin in Windows->Plugins within the editor, but leaving the config file set,")]),e._v(" "),n("p",[e._v("is pretty much guaranteed to cause a crash.")]),e._v(" "),n("p",[e._v("soooo")]),e._v(" "),n("h3",{attrs:{id:"disabling-my-editor-mode-entire-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#disabling-my-editor-mode-entire-plugin"}},[e._v("#")]),e._v(" Disabling My Editor Mode / Entire Plugin")]),e._v(" "),n("p",[e._v("To disable my editor mode you should *always* comment out the DefaultEngine.ini line first!")]),e._v(" "),n("p",[e._v("Then you can load the editor again and disable the plugin entirely")]),e._v(" "),n("p",[e._v("My plugin cannot corrupt or damage your main UE4 install in any way,")]),e._v(" "),n("p",[e._v("If you get a crash dont panic, just read these steps again")]),e._v(" "),n("p",[n("strong",[e._v('" Help I can\'t Load UE4 Anymore "')])]),e._v(" "),n("p",[e._v("The worst that can happen is that the config file gets setup up wrong,")]),e._v(" "),n("p",[e._v("and you wont be able to load the editor,")]),e._v(" "),n("p",[e._v("and it will crash if you try cause it can't find the new Engine class.")]),e._v(" "),n("p",[n("strong",[e._v("But, this is extremely easy to fix!")])]),e._v(" "),n("p",[e._v("just comment out the line that you added in your config file and you are guaranteed good-to-go")]),e._v(" "),n("p",[e._v("[/Script/Engine.Engine]\nUnrealEdEngine=/Script/VictoryEdEngine.VictoryEdEngine")]),e._v(" "),n("h2",{attrs:{id:"instanced-static-mesh-editor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#instanced-static-mesh-editor"}},[e._v("#")]),e._v(" Instanced Static Mesh Editor")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:InstancedStaticMeshEditor.jpg",title:"800x"}},[n("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/b/b2/InstancedStaticMeshEditor.jpg",alt:"800x"}})])]),e._v(" "),n("p",[n("strong",[e._v("Introduction Video")])]),e._v(" "),n("p",[n("strong",[e._v("Setup")])]),e._v(" "),n("p",[e._v("I recently added a feature so that you can select many static mesh actors that all have the same static mesh and convert them into 1 instanced static mesh!")]),e._v(" "),n("p",[e._v("This process can be reversed at any time to make individual edits!")]),e._v(" "),n("p",[e._v("In this way you can enable UE4 to render 1000s of static meshes while maintaining very high FPS!")]),e._v(" "),n("p",[e._v("Now you can edit instanced static meshes with all the tools you are familiar with and convert all the static mesh actors when you are done, to get a huge FPS boost!")]),e._v(" "),n("h3",{attrs:{id:"update-part-of-victory-ed-engine"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update-part-of-victory-ed-engine"}},[e._v("#")]),e._v(" Update: Part of Victory Ed Engine")]),e._v(" "),n("p",[e._v("My ISM Editor feature is now part of the Victory Ed Engine plugin which is separate from the Victory BP Library pluginÂ ðŸ˜ƒ")]),e._v(" "),n("h3",{attrs:{id:"mandatory-setup-step"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mandatory-setup-step"}},[e._v("#")]),e._v(" Mandatory Setup Step")]),e._v(" "),n("p",[e._v("To make my Instanced Static Mesh system work with your project you have to choose a ISM actor class. You can either create your own by adding a Instanced Static Mesh Actor to a new Actor blueprint, making the ISM component the root component, or you can use the VictoryISM class in my Victory BP Library plugin!")]),e._v(" "),n("p",[e._v("1. Go to Project Settings->Game->Victory Ed Engine")]),e._v(" "),n("p",[e._v("2. Choose your own custom Instanced Static Mesh Actor class, or use the one from my Victory BP Library plugin")]),e._v(" "),n("p",[e._v("3. Select a bunch of static mesh actors and press i to convert them, shift + i to convert back, also work with undo/redo")]),e._v(" "),n("p",[e._v("4. Enjoy!")]),e._v(" "),n("h2",{attrs:{id:"works-with-ue4-undo-system"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#works-with-ue4-undo-system"}},[e._v("#")]),e._v(" Works With UE4 Undo System")]),e._v(" "),n("p",[e._v("My Vertex Snap Editor Mode now works with UE4's undo system!")]),e._v(" "),n("p",[e._v("Yay!")]),e._v(" "),n("p",[e._v("You can undo as many individual snap events as you want!")]),e._v(" "),n("p",[e._v("Note that I only save an undo state when you release the V key to avoid flooding the system while you are continuously snapping while holding down V.")]),e._v(" "),n("p",[e._v("So make sure you release the V key to save your final state before using CTRL + Z")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:Undo.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/b/bb/Undo.jpg/600px-Undo.jpg",alt:"Undo.jpg"}})])]),e._v(" "),n("p",[e._v("Rama")]),e._v(" "),n("h2",{attrs:{id:"newest-editor-feature"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#newest-editor-feature"}},[e._v("#")]),e._v(" Newest Editor Feature:")]),e._v(" "),n("h3",{attrs:{id:"new-display-options"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-display-options"}},[e._v("#")]),e._v(" New Display Options")]),e._v(" "),n("p",[e._v("Now pressing the U key is a display toggle!")]),e._v(" "),n("ul",[n("li",[e._v("Default = only show the vertex the mouse is hovering over")]),e._v(" "),n("li",[e._v("Press U once to show all vertices")]),e._v(" "),n("li",[e._v("Press U again to show no vertices")]),e._v(" "),n("li",[e._v("Press U again to be back to showing cursor-highlighted vertices only")]),e._v(" "),n("li",[e._v("etc")])]),e._v(" "),n("h3",{attrs:{id:"new-workflow-3-27-14"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-workflow-3-27-14"}},[e._v("#")]),e._v(" New Workflow(3/27/14)")]),e._v(" "),n("ul",[n("li",[e._v("Press V to select a vertex")]),e._v(" "),n("li",[e._v("Hold down V to continuously snap to vertices of other highlighted meshes")]),e._v(" "),n("li",[e._v("Release to finalize the move")])]),e._v(" "),n("h3",{attrs:{id:"new-snap-to-surface-normal-workflow"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-snap-to-surface-normal-workflow"}},[e._v("#")]),e._v(" New Snap to Surface Normal Workflow")]),e._v(" "),n("ul",[n("li",[e._v("Press V and and also hold down shift")]),e._v(" "),n("li",[e._v("If you fiddle with your approach angle and move the mouse little bits, you can get some really great normal alignments without much effort")])]),e._v(" "),n("p",[e._v("Enjoy!")]),e._v(" "),n("p",[e._v("Rama")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VertexSnapContinuous.jpg"}},[n("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/8/8d/VertexSnapContinuous.jpg/486px-VertexSnapContinuous.jpg",alt:"VertexSnapContinuous.jpg"}})])]),e._v(" "),n("h2",{attrs:{id:"drop-static-meshes-to-nearest-surface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#drop-static-meshes-to-nearest-surface"}},[e._v("#")]),e._v(" Drop Static Meshes to Nearest Surface!")]),e._v(" "),n("p",[n("strong",[e._v("Now you can just press the Y key in the UE4 Editor")])]),e._v(" "),n("p",[e._v("to drop the selected Static Mesh or Static Meshes to the nearest surface in the level!")]),e._v(" "),n("p",[e._v("You can drop Static Meshes down to each other too!")]),e._v(" "),n("p",[e._v("My algorithm takes into account the actual shape of the static mesh being dropped, as well as the landscape/level/meshes it is being dropped onto!")]),e._v(" "),n("p",[n("strong",[e._v("If you have multiple objects selected")]),e._v(", they are treated as one big object and all the surfaces are calculated together, and the group is dropped, maintaining formation, to the nearest surface within your level.")]),e._v(" "),n("h2",{attrs:{id:"vertex-snap-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vertex-snap-plugin"}},[e._v("#")]),e._v(" Vertex Snap Plugin")]),e._v(" "),n("p",[e._v("My extended Editor Engine detects when the user clicks on a static mesh actor, and activates my Vertex Snapping Editor Mode.")]),e._v(" "),n("h3",{attrs:{id:"ue4-editor-plugin-no-code-compile-required"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ue4-editor-plugin-no-code-compile-required"}},[e._v("#")]),e._v(" UE4 Editor Plugin, No Code Compile Required")]),e._v(" "),n("p",[e._v("Dear Community,")]),e._v(" "),n("p",[e._v("This is my very first "),n("strong",[e._v("new Editor Mode")]),e._v(" for the main UE4 Editor!")]),e._v(" "),n("p",[e._v("This is a tiny ( under 10 MB ) plugin, that you can download and use without having to compile any source code.")]),e._v(" "),n("p",[e._v("Your project "),n("em",[e._v("does not")]),e._v(" have to be a code-based project!")]),e._v(" "),n("p",[n("strong",[e._v("It adds 3 new features")])]),e._v(" "),n("p",[e._v('1. Toggle instantly moving selected static meshes to the mouse cursor, to quickly move them around, or "teleport" them across the map, supports Multi Selection.')]),e._v(" "),n("p",[e._v("2. Press K to reset a static mesh actor's rotation")]),e._v(" "),n("p",[e._v("3. Vertex Snapping! Optionally snap to surface normal of destination static mesh")]),e._v(" "),n("p",[e._v("-verticies can be resized anytime using + or -\n-you can cycle among 5 different verticies display options at any time\n-you can toggle vertex displaying by pressing Y.")]),e._v(" "),n("p",[e._v("All of the features are related to static mesh actors and my editor mode disables itself if you are not working with a static mesh actor.")]),e._v(" "),n("p",[e._v("It is super easy to enable or disable my editor mode, or suspend it entirely after trying it out.")]),e._v(" "),n("p",[n("strong",[e._v("With my editor mode plugin you can enjoy some new features for your UE4 Editor Experience!")])]),e._v(" "),n("h2",{attrs:{id:"victory-editor-align-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#victory-editor-align-mode"}},[e._v("#")]),e._v(" Victory Editor Align Mode")]),e._v(" "),n("h3",{attrs:{id:"features"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[e._v("#")]),e._v(" Features:")]),e._v(" "),n("h4",{attrs:{id:"instant-mouse-move-of-static-mesh-actor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#instant-mouse-move-of-static-mesh-actor"}},[e._v("#")]),e._v(" Instant Mouse Move of Static Mesh Actor")]),e._v(" "),n("p",[e._v("-Press T key to toggle this mode! (mapping it to a mouse button proved too complicated given all existing editor mouse button functionality)")]),e._v(" "),n("p",[e._v("-The selected Static Mesh(es) will move instantly to follow the mouse cursor anywhere in the XY plane, staying on the current Z")]),e._v(" "),n("p",[e._v("-This can be used to instantly move objects to a location by a. selecting them all b. moving to your desired destination location c. press T key and they will all warp to your current locationÂ ðŸ˜ƒ")]),e._v(" "),n("p",[e._v("-Supports multi-selection")]),e._v(" "),n("h4",{attrs:{id:"reset-any-static-mesh-actor-s-rotation-to-0"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reset-any-static-mesh-actor-s-rotation-to-0"}},[e._v("#")]),e._v(" Reset any Static Mesh Actor's rotation to 0")]),e._v(" "),n("p",[e._v("-Press the K key -just a handy little feature, -extra-useful if the vertex Snap-By-Surface-Normal goes wonky")]),e._v(" "),n("h4",{attrs:{id:"vertx-display-and-snapping"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vertx-display-and-snapping"}},[e._v("#")]),e._v(" Vertx Display and Snapping")]),e._v(" "),n("p",[e._v("-Press Y key to toggle displaying of static mesh verticies! -Press B to toggled between five different display types for all verticies a. simple crosshair b. solid rectangle c. 3D box d. diamond (pretty good even at 4000 verticies) e. sphere (slow for > 3000 verticies)")]),e._v(" "),n("p",[e._v("-Hold SHIFT while selecting the second vertex to use Snap-By-Surface-Normal, which will try to align the source static mesh actor with the surface of the destination actor.")]),e._v(" "),n("p",[e._v("-snap selected static mesh actor by chosen vertex to the chosen vertex of another static mesh actor,")]),e._v(" "),n("p",[e._v("-can do whole process with 3 input key presses total!")]),e._v(" "),n("h4",{attrs:{id:"vertex-resizing"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vertex-resizing"}},[e._v("#")]),e._v(" Vertex Resizing")]),e._v(" "),n("p",[e._v("You can resize all the verticies at once by pressing and holding -/+")]),e._v(" "),n("h4",{attrs:{id:"verticies-dynamically-update"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#verticies-dynamically-update"}},[e._v("#")]),e._v(" Verticies Dynamically Update")]),e._v(" "),n("p",[e._v("No matter how you scale or rotate the mesh the drawn verticies will update correctly:)")]),e._v(" "),n("h4",{attrs:{id:"vertex-selection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vertex-selection"}},[e._v("#")]),e._v(" Vertex Selection")]),e._v(" "),n("p",[e._v("You can move/rotate the selected static mesh actor after selecting one of its verticies, and the selection will be maintained and updated.")]),e._v(" "),n("h3",{attrs:{id:"workflow-efficiency"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#workflow-efficiency"}},[e._v("#")]),e._v(" WorkFlow Efficiency")]),e._v(" "),n("h4",{attrs:{id:"fast-user-interface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fast-user-interface"}},[e._v("#")]),e._v(" Fast User Interface")]),e._v(" "),n("p",[e._v("Vertex snapping can be accompished in three input presses total")]),e._v(" "),n("p",[e._v("1. select the actor you are going to move 2. hover over chosen vertex and press V 3. hover over chosen vertex of other mesh and press V")]),e._v(" "),n("p",[e._v("The reason this only takes 3 inputs is because when you hover the mouse over other static mesh actors,")]),e._v(" "),n("p",[e._v("my editor mode automatically highlights all of the vertices and the vertex that is closest to the cursor.")]),e._v(" "),n("p",[n("strong",[e._v("Why not use Mouse Click?")])]),e._v(" "),n("p",[e._v("The reason the vertex selections are key presses not mouse clicks:")]),e._v(" "),n("p",[e._v("-any kind of mouse click tends to change selection, and I dont wish to override this functionality")]),e._v(" "),n("p",[e._v("-it's easy to miss-click with the mouse on a vertex that is at a corner, and end up selecting the landscape instead")]),e._v(" "),n("p",[e._v("-the thematic consistency provided by using a same-key-press to do the whole snap process feels niceÂ ðŸ˜ƒ")]),e._v(" "),n("p",[n("strong",[e._v("The flow becomes:")])]),e._v(" "),n("p",[e._v("hover mouse over vertex press key V")]),e._v(" "),n("p",[e._v("hover mouse over other vertex press same key V")]),e._v(" "),n("p",[e._v("Snap done!")]),e._v(" "),n("h4",{attrs:{id:"speed-using-the-pdi-primitive-draw-interface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#speed-using-the-pdi-primitive-draw-interface"}},[e._v("#")]),e._v(" Speed: Using the PDI / Primitive Draw Interface")]),e._v(" "),n("p",[e._v("In case you are curious, I am drawing directly to the PDI, the fundamental drawing surface, using DrawPoint.")]),e._v(" "),n("p",[e._v("This is about as light-weight as I know how to get at present")]),e._v(" "),n("p",[e._v("An advantage of using PDI and DrawPoint is that only verticies in the chosen depth priority will draw.")]),e._v(" "),n("p",[n("strong",[e._v("This enables me to hide verticies")]),e._v(" that you would not realistically want to click on from the opposite side of a mesh.")]),e._v(" "),n("h4",{attrs:{id:"high-vertex-counts"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#high-vertex-counts"}},[e._v("#")]),e._v(" High Vertex Counts")]),e._v(" "),n("p",[e._v("-Verticies are not drawn if the object vertex count is too high (10,000 at moment), as that could cause a long delay or even a hang if you click on a high-res statue or something like thatÂ ðŸ˜ƒ")]),e._v(" "),n("p",[e._v("- I automatically switch sphere vertex display mode down to box mode if vertex cound is > 5000 to prevent slowdown if cycling through the B key")]),e._v(" "),n("h4",{attrs:{id:"editor-environment-integration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#editor-environment-integration"}},[e._v("#")]),e._v(" Editor Environment Integration")]),e._v(" "),n("p",[e._v("-Victory Align Mode auto-activates when you click on Static Mesh Actors,")]),e._v(" "),n("p",[e._v("-Press P key to restore previous Editor mode and Real Time Status instantly")]),e._v(" "),n("p",[e._v("-Clicking on non-static mesh actors will restore previous Editor Mode")]),e._v(" "),n("p",[n("strong",[e._v("Example:")])]),e._v(" "),n("p",[e._v("If you are busy clicking on stuff and you end up in my editor mode by accident, press the P key to instantly revert to prevous mode")]),e._v(" "),n("p",[n("strong",[e._v("Interface:")])]),e._v(" "),n("p",[e._v("-There is a useful hover-button in top left of window that will show you all the hotkeys for this Editor Mode any time you hover mouse over it")]),e._v(" "),n("p",[e._v("-The hover-button fades itself out to be less visual distraction, but hovering mouse over it will fade it back in and display helpful info")]),e._v(" "),n("p",[e._v("-When using the Instant Mouse Move by tapping the T key,")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" the move/rotate/scale main editor widget disappears to let you know you are in that mode and also because it is not really usable while using the T-key mode.\n")])])]),n("p",[e._v("-Deselecting or exiting the mode cancels the Instant T(ranslate) key mode.")]),e._v(" "),n("h3",{attrs:{id:"using-vertex-snap-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#using-vertex-snap-mode"}},[e._v("#")]),e._v(" Using Vertex Snap Mode")]),e._v(" "),n("p",[e._v("Once you click on a static mesh actor, if the verticies are not showing, press the V key")]),e._v(" "),n("p",[e._v("1. Hover mouse on vertex,")]),e._v(" "),n("p",[e._v("2. press V")]),e._v(" "),n("p",[e._v("3. Hover mouse over other static mesh and one of its verticies,")]),e._v(" "),n("p",[e._v("4. press V")]),e._v(" "),n("p",[e._v("If you are using Align-By-Surface-Normal, the selected static mesh will attempt to orient itself to the surface closest to the vertex of the other static mesh.")]),e._v(" "),n("h3",{attrs:{id:"vertex-editor-plugin-summary"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vertex-editor-plugin-summary"}},[e._v("#")]),e._v(" Vertex Editor Plugin Summary")]),e._v(" "),n("p",[n("strong",[e._v("Light-Weight for Your UE4 Editing Experience")])]),e._v(" "),n("p",[e._v("I tried to make the vertex-selection aspect of my editor mode as light-weight as possible,")]),e._v(" "),n("p",[e._v("- no traces - no collision - no extra actors involved - just drawing to the PDI")]),e._v(" "),n("p",[e._v("There is not actually any 3D collision for the verticies!")]),e._v(" "),n("p",[e._v('I defined a "button" struct which stores the projected coordinates of the verticies, plus the resizable drawn-vertex scaling.')]),e._v(" "),n("p",[e._v("So as you scale the verticies the buttons grow to accommodate.")]),e._v(" "),n("p",[e._v("Whenever the view changes, the buttons are freshed.")]),e._v(" "),n("p",[e._v("If there is no input to the UE4 Editor or you have it in the background, the buttons are never refreshed")]),e._v(" "),n("p",[e._v("In Summary, it's just a bunch of invisible floats that are determining when you are clicking or highlighting the verticies of the Static Mesh Actors")]),e._v(" "),n("p",[n("strong",[e._v("Have Fun")])]),e._v(" "),n("p",[e._v("Have fun with my editor mode!")]),e._v(" "),n("p",[n("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[e._v("Rama")]),e._v(" ("),n("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[e._v("talk")]),e._v(")")]),e._v(" "),n("h2",{attrs:{id:"my-entire-plugin-c-source-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#my-entire-plugin-c-source-code"}},[e._v("#")]),e._v(" My Entire Plugin C++ Source Code")]),e._v(" "),n("h3",{attrs:{id:"credits"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#credits"}},[e._v("#")]),e._v(" Credits")]),e._v(" "),n("p",[e._v("Feel free to use my C++ code as an outline for making your own Editor Mode Plugin!")]),e._v(" "),n("p",[e._v("Just please give me credit somewhere appropriate.")]),e._v(" "),n("p",[e._v("I did not use any algorithms or math equations from any source,")]),e._v(" "),n("p",[e._v("I wrote all the code myself and just used Epic's awesome UE4 Beta .h files as a reference.")]),e._v(" "),n("p",[n("strong",[e._v("This code does not contain any UE4 C++ source code, as I did not have access to it when I wrote this plugin.")])]),e._v(" "),n("h3",{attrs:{id:"victoryedengine"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#victoryedengine"}},[e._v("#")]),e._v(" VictoryEdEngine")]),e._v(" "),n("p",[e._v("This is the class that becomes your new UE4 Engine class, and it must be set to be used by UE4 via DefaultEngine.ini")]),e._v(" "),n("p",[e._v("[/Script/Engine.Engine]\n;UnrealEdEngine=/Script/UnrealEd.UnrealEdEngine\nUnrealEdEngine=/Script/VictoryBPLibrary.VictoryEdEngine")]),e._v(" "),n("h4",{attrs:{id:"h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#h"}},[e._v("#")]),e._v(" .H")]),e._v(" "),n("p",[e._v('#pragma once\nÂ \n#include "UnrealEd.h"\n#include "VictoryEdAlignMode.h"\n#include "VictoryEdEngine.generated.h"\nÂ \nUSTRUCT()\nstruct FDropToClosestSurfaceData\n{\nGENERATED_USTRUCT_BODY()\nÂ \nUPROPERTY()\nAStaticMeshActor* TheActor;\nÂ \nUPROPERTY()\nFVector SurfaceLoc;\nÂ \nUPROPERTY()\nfloat DistSquared;\nÂ \nFDropToClosestSurfaceData()\n{\nDistSquared = 1000000000;\nSurfaceLoc = FVector::ZeroVector;\nTheActor = NULL;\n}\n};\nUSTRUCT()\nstruct FVButton\n{\nGENERATED_USTRUCT_BODY()\nÂ \nUPROPERTY()\nint32 Vibe;\nÂ \nUPROPERTY()\nFVector PointInWorld;\nÂ \nUPROPERTY()\nfloat minX;\nÂ \nUPROPERTY()\nfloat maxX;\nÂ \nUPROPERTY()\nfloat minY;\nÂ \nUPROPERTY()\nfloat maxY;\nÂ \nFVButton()\n{\nVibe = -1;\n}\n};\nÂ \nUCLASS(config=Engine)\nclass UVictoryEdEngine : public UUnrealEdEngine\n{\nGENERATED_UCLASS_BODY()\nÂ \nbool CreatedVictoryEdMode;\nÂ \n//the user-selected mode prior to initiating VictoryEdMode\nFEditorModeID PrevModeID;\nÂ \nÂ \n//utility\nÂ \n//Assets\npublic:\nÂ \n/*\nUPROPERTY()\nUStaticMesh* AssetSM_EngineCube;\n//StaticMesh\'/Engine/EngineMeshes/Cube.Cube\'\nÂ \nÂ \nUPROPERTY()\nUMaterial* ColorMat;\nÂ \nUPROPERTY()\nUMaterialInstanceDynamic* ColorMatInst_GlowyBlue;\nÂ \nUPROPERTY()\nUMaterialInstanceDynamic* ColorMatInst_GlowyRed;\nÂ \nUPROPERTY()\nUMaterialInstanceDynamic* ColorMatInst_GlowyYellow;\n*/\nÂ \n//Font\npublic:\nUPROPERTY()\nUFont* VictoryEditorFont;\n//Font\'/Engine/EngineFonts/RobotoDistanceField.RobotoDistanceField\'\nÂ \nFORCEINLINE UFont* GetVictoryFont()\n{\nif(VictoryEditorFont) return VictoryEditorFont;\nreturn GetStatsFont();\n}\nÂ \n//Selection\npublic:\nAActor* VSelectedActor;\nÂ \nTArray<FVector> SelectionRelativeOffsets;\nvoid GetSelectedActorsRelativeOffsets();\nbool SelectedActorVerticiesNeedsUpdating;\nbool ClearSelectedVertex;\nÂ \n//core\npublic:\nstatic const FName VictoryEditorModeID;\nvoid SwitchToVictoryEdMode();\nÂ \nFORCEINLINE void ExitVictoryAlignMode()\n{\n//Deactivate Mode\nGEditorModeTools().DeactivateMode( VictoryEditorModeID );\nÂ \n//Restore Previous Realtime State\n//GCurrentLevelEditingViewportClient->RestoreRealtime(true); //allow disable\nÂ \n//Activate Previous Mode\nGEditorModeTools().ActivateMode(PrevModeID);\n}\nÂ \n//tests\npublic:\nvoid RunTests();\nÂ \nprotected:\nÂ \nvirtual void NoteSelectionChange() OVERRIDE;\nÂ \nvirtual void Tick(float DeltaSeconds, bool bIdleMode) OVERRIDE;\n};')]),e._v(" "),n("h4",{attrs:{id:"cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cpp"}},[e._v("#")]),e._v(" .CPP")]),e._v(" "),n("p",[e._v('// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\nÂ \n//Unreal Editor Fun With Rama\nÂ \n//#include "VictoryGame.h"\n#include "VictoryBPLibraryPrivatePCH.h"\nÂ \nÂ \nconst FName UVictoryEdEngine::VictoryEditorModeID = FName("VictoryEditorMode");\nÂ \nUVictoryEdEngine::UVictoryEdEngine(const class FPostConstructInitializeProperties& PCIP)\n: Super(PCIP)\n{\nCreatedVictoryEdMode = false;\nÂ \nPrevModeID = FBuiltinEditorModes::EM_Default;\nÂ \n//Font\nstatic ConstructorHelpers::FObjectFinder<UFont> TheFontOb(TEXT("Font\'/Engine/EngineFonts/RobotoDistanceField.RobotoDistanceField\'"));\nVictoryEditorFont = (UFont*)TheFontOb.Object;\nÂ \n/*\n//Cube\nstatic ConstructorHelpers::FObjectFinder'),n("UStaticMesh",[e._v(" StaticMeshOb_cube(TEXT(\"StaticMesh'/Engine/EngineMeshes/Cube.Cube'\"));\nAssetSM_EngineCube= StaticMeshOb_cube.Object;\nÂ \n//Color Mat Inst\nstatic ConstructorHelpers::FObjectFinder"),n("UMaterial",[e._v(' ColorMatInstOb(TEXT("Material\'/Engine/EditorMaterials/Utilities/LinearColorPicker_MAT.LinearColorPicker_MAT\'"));\nColorMat = ColorMatInstOb.Object;\nÂ \n//Create Instance\nif(ColorMat)\n{\nColorMatInst_GlowyBlue = UMaterialInstanceDynamic::Create(ColorMat, this);\nif(ColorMatInst_GlowyBlue) ColorMatInst_GlowyBlue->SetVectorParameterValue(FName("Color"), FLinearColor(0,0,1,1));\nÂ \nColorMatInst_GlowyRed = UMaterialInstanceDynamic::Create(ColorMat, this);\nif(ColorMatInst_GlowyRed) ColorMatInst_GlowyRed->SetVectorParameterValue(FName("Color"), FLinearColor(1,0,0,1));\nÂ \nColorMatInst_GlowyYellow = UMaterialInstanceDynamic::Create(ColorMat, this);\nif(ColorMatInst_GlowyYellow) ColorMatInst_GlowyYellow->SetVectorParameterValue(FName("Color"), FLinearColor(1,1,0,1));\n}\n*/\n}\nÂ \nvoid UVictoryEdEngine::SwitchToVictoryEdMode()\n{\n//Create it if it not exist yet\nif(!CreatedVictoryEdMode)\n{\n//Proper way to make a shared refÂ ???\nTSharedRef<class FVictoryEdAlignMode,ESPMode::Fast> VictoryEdMode = MakeShareable( new FVictoryEdAlignMode() );\nÂ \n//Init VictoryEdMode\nVictoryEdMode->JoyInit(this);\nÂ \n//Register\nGEditorModeTools().RegisterMode(VictoryEdMode);\nÂ \nCreatedVictoryEdMode = true;\n}\nÂ \n//~~~ Store Previous Editor Mode ~~~\nTArray<FEdMode*> OutActiveModes;\nFEdMode* CurMode = NULL;\nGEditorModeTools().GetActiveModes( OutActiveModes );\nÂ \nfor(int32 Itr = 0; Itr < OutActiveModes.Num(); Itr++)\n{\nCurMode = OutActiveModes[Itr];\nif(!CurMode) continue;\nif(CurMode->GetID() == VictoryEditorModeID ) continue;\nÂ \nPrevModeID = CurMode->GetID();\n//UE_LOG(Victory,Warning, TEXT("Previous Editor Mode:Â %s"), *CurMode->GetID().ToString() );\n}\nÂ \n//Activate Victory Editor Mode\nGEditorModeTools().ActivateMode(VictoryEditorModeID);\n}\nÂ \nvoid UVictoryEdEngine::RunTests()\n{\n//tests\n}\nÂ \nÂ \nvoid UVictoryEdEngine::GetSelectedActorsRelativeOffsets()\n{\nSelectionRelativeOffsets.Empty();\n//~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//Get the Relative Offsets\nconst FVector Origin = VSelectedActor->GetActorLocation();\nÂ \nAActor* VSelectItrActor;\nfor(FSelectionIterator VSelectItr = GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nVSelectItrActor = Cast<AActor>(*VSelectItr);\nif(!VSelectItrActor) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \nSelectionRelativeOffsets.Add(VSelectItrActor->GetActorLocation() - Origin );\n//UE_LOG(Victory, Error, TEXT("Relative offsetÂ %s"), *SelectionRelativeOffsets[SelectionRelativeOffsets.Num() - 1].ToString());\n};\n}\nvoid UVictoryEdEngine::NoteSelectionChange()\n{\nSuper::NoteSelectionChange();\n//~~~~~~~~~~~~~~~~~\nÂ \nif(!GetSelectedActors()) return;\nAActor* SelectedActor = Cast<AActor>(GetSelectedActors()->GetTop(AActor::StaticClass()));\nif(!SelectedActor) return;\n//~~~~~~~~~~~~~~~\nÂ \nif(SelectedActor != VSelectedActor) ClearSelectedVertex = true;\nÂ \n//Update\nVSelectedActor = SelectedActor;\nÂ \n//Always Refresh\nSelectedActorVerticiesNeedsUpdating = true;\nÂ \n//For use with multi-select moves\nGetSelectedActorsRelativeOffsets();\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//Only Activate for Static Mesh Actors Currently\nif(SelectedActor->IsA(AStaticMeshActor::StaticClass()))\n{\n//Switch to Victory Align Mode if not active already\nif(!GEditorModeTools().IsModeActive(VictoryEditorModeID))\nSwitchToVictoryEdMode();\n}\nelse\n{\n//Deactivate Mode for Non-Static Mesh Actors\nExitVictoryAlignMode();\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//RunTests();\nÂ \n//UE_LOG(Victory, Warning, TEXT("New Selected ActorÂ %s"), *SelectedActor->GetName() );\n//UE_LOG(Victory, Warning, TEXT("New Selected Actor LocationÂ %s"), *SelectedActor->GetActorLocation().ToString() );\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \nvoid UVictoryEdEngine::Tick(float DeltaSeconds, bool bIdleMode)\n{\nSuper::Tick(DeltaSeconds,bIdleMode);\nÂ \n}')])],1)],1),e._v(" "),n("h3",{attrs:{id:"victoryedmode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#victoryedmode"}},[e._v("#")]),e._v(" VictoryEdMode")]),e._v(" "),n("p",[e._v("Since the EdMode is a pure C++ class, it must go in the Public directory of your plugin file structure!")]),e._v(" "),n("h4",{attrs:{id:"h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#h-2"}},[e._v("#")]),e._v(" .H")]),e._v(" "),n("p",[e._v('#pragma once\nÂ \n#include "UnrealEd.h"\n#include "Editor.h"\n//#include "BSPOps.h"\nÂ \nclass UVictoryEdEngine;\nÂ \nstruct FVButton;\nstruct FDropToClosestSurfaceData;\nÂ \nclass FVictoryEdAlignMode : public FEdMode\n{\nÂ \n//Statics\npublic:\nstatic const FColor RV_VRed;\nstatic const FColor RV_VBlue;\nstatic const FColor RV_VYellow;\nstatic const FLinearColor RV_Red;\nstatic const FLinearColor RV_Yellow;\nstatic const FLinearColor RV_Blue;\nÂ \n//Display Updates\npublic:\nbool DoSingleDisplayUpdate;\n//Drop to Surface\npublic:\nÂ \n//if multiple selected, the test runs on each and finds the nearest of nearest surfaces\nvoid DropSelectedActorsToNearestSurface();\nÂ \nFDropToClosestSurfaceData* GetActorWithShortestDrop(TArray<FDropToClosestSurfaceData>& TheData);\nÂ \nFORCEINLINE void GetBottomSurfacePoint(AStaticMeshActor* TheSMA, FVector& BottomMostPoint)\n{\nBottomMostPoint = FVector::ZeroVector;\nif(!TheSMA) return;\nif(!TheSMA->StaticMeshComponent) return;\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nFVector Origin;\nFVector Extent;\nTheSMA->GetActorBounds(true,Origin,Extent);\nTheSMA->StaticMeshComponent->GetDistanceToCollision(Origin - FVector(0,0,Extent.Z + 100),BottomMostPoint);\n}\n//Vertex:\npublic:\nÂ \nvoid GetSelectedVertexLocation(FVector& LocOut);\nÂ \n//Snap Key Pressed!\nbool SnapKeyPressed;\nÂ \n//VertexDisplayChoice\nuint8 VertexDisplayChoice;\nÂ \n//Snap!\nvoid DoVertexSnap(const FVector& Dest);\nÂ \nFPositionVertexBuffer* \t\t\tSelectedVertexBuffer;\nFPositionVertexBuffer* \t\t\tHighlightedVertexBuffer;\nÂ \n//Highlighted Actor\nAStaticMeshActor* \t\t\t\tHighlightedActor;\nÂ \n//Buttons\nTArray<FVButton> SelectedActorButtons;\nTArray<FVButton> HighlightedActorButtons;\nÂ \n//CheckArrays - find the vertex button closest to camera\nTArray<FVButton*> ClosestSelectedActorButtons;\nTArray<FVButton*> ClosestHighlightedActorButtons;\nint32 FindClosestOfButtons(TArray<FVButton*> Inbuttons);\nvoid RefreshVertexButtons(const FSceneView* View);\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//Vertex Scale\nfloat CurrentVerticiesScale;\nbool PlusIsDown;\nbool MinusIsDown;\nbool DoDrawVerticies;\nÂ \n//Index of Vertex, so actor can move and maintain selection\nint32 SelectedVertexForSelectedActor;\nint32 HighlightedVertexForSelectedActor;\nint32 HighlightedVertexForHighlightedActor;\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nFVector VertexWorldSpace;\nFVector2D Vertex2DCenter;\nÂ \n//Vertex Functions\nvoid PDI_DrawVerticies(const FSceneView* View, FPrimitiveDrawInterface* PDI, const FPositionVertexBuffer* VertexBuffer, const FTransform& SMATransform, bool DrawingSelectedActor);\nÂ \n//Get Vertex Bufer\nFPositionVertexBuffer* GetVerticies(AStaticMeshActor* TheSMA);\nÂ \n//Mouse Instant Move SMA\npublic:\nbool UsingMouseInstantMove;\nvoid ProcessMouseInstantMove(FLevelEditorViewportClient* ViewportClient);\n//\n//Selection\npublic:\nAActor* VSelectItrActor;\nÂ \n//Input Related\npublic:\nFVector2D \t\tMouseLocation;\nFVector2D \t\tPrevMouseLocation;\nFVector \tCursorWorldPrevPos;\nFVector \tCursorWorldPos;\nFVector \tCursorWorldDir;\nFVector \tCursorWorldDelta;\nÂ \nvoid InputKeyPressed(EKey Key);\nvoid InputKeyReleased(EKey Key);\nvoid InputKeyDoubleClick(EKey Key);\nÂ \nvoid MiddleMouseEvent(EInputEvent Event);\nvoid LeftMouseClick();\nÂ \nÂ \n//States\nbool RMBDown;\nbool XDown;\nbool YDown;\nbool ShiftDown;\nÂ \n//HUD\npublic:\nFIntPoint ViewportSize;\nÂ \nvoid DrawHotkeyToolTip(FCanvas* Canvas);\nvoid DrawMouseCoordinates(FCanvas* Canvas);\nÂ \nvoid CheckCursorInButtons(FCanvas* Canvas);\nTArray<FVButton> \tVictoryButtons;\nint32 \t\t\t\t\tActiveButton_Vibe;\nFVButton* \t\t\tCurCheckButton;\nvoid RefreshVictoryButtons();\nbool PendingButtonRefresh;\nÂ \n//Utility\npublic:\nvoid DrawVictoryText(FCanvas* Canvas, const FString& TheStr, float X, float Y, float TheScale=1 );\nvoid DrawVictoryTextWithColor(FCanvas* Canvas, const FString& TheStr, float X, float Y, FLinearColor TheColor=FLinearColor(1,0,1,1), float TheScale=1 );\nvoid DrawVictoryLine(FCanvas* Canvas, const FVector2D& Start, const FVector2D& End, FLinearColor TheColor=FLinearColor(1,0,1,1), float Thick=0 );\nvoid DrawVictoryRect(FCanvas* Canvas, float X, float Y, float Width, float Height, FLinearColor Color=FLinearColor(0,0,1,1));\nÂ \n//Scene-view Level Project and Deproject\nvoid VictoryProject(\t\tconst FSceneView* View,const FVector& WorldPoint,\t\tFVector2D& OutPixelLocation);\nvoid VictoryDeProject(\tconst FSceneView* View,const FVector2D& ScreenPoint, FVector& out_WorldOrigin, FVector& out_WorldDirection);\nÂ \n//Box from Point with Size\nFORCEINLINE FBox BoxFromPointWithSize(const FVector& InCenter, const float& Size)\n{\nreturn FBox(\nInCenter+(FVector(1,1,1) * -Size/2),\nInCenter+(FVector(1,1,1) * Size/2)\n);\n}\nÂ \n//RV\npublic:\nint32 RV_Int32;\nfloat RV_yStart;\nfloat RV_Float;\nFVector RV_Vect;\nFRotator RV_Rot;\nFCollisionQueryParams RV_TraceParams;\nFHitResult RV_Hit;\nAActor* RV_HitActor;\n//Victory Title\n//Time\npublic:\nFDateTime VictoryTitleAppearTime;\nFTimespan CurTimeSpan;\nbool VictoryTitleVisible;\nbool FadeInVictoryTitle;\nfloat VictoryTitleAlpha;\nÂ \nFORCEINLINE void VictoryTitleAppears()\n{\nVictoryTitleAppearTime = FDateTime::Now();\nVictoryTitleAlpha = 1;\nVictoryTitleVisible = true;\nFadeInVictoryTitle = false;\n}\nÂ \n//Tick\npublic:\nvoid Tick_VictoryTitle(FLevelEditorViewportClient* ViewportClient);\nvoid Tick_VictoryTitleFadeIn();\nvoid Tick_VictoryInterface(FLevelEditorViewportClient* ViewportClient);\nÂ \n//Core\npublic:\nUPROPERTY()\nUVictoryEdEngine* VictoryEngine;\nÂ \nbool ReEntering;\nÂ \n//Constructor/Destructor\npublic:\nFVictoryEdAlignMode();\n~FVictoryEdAlignMode();\nvoid JoyInit(UVictoryEdEngine* EnginePtr);\nÂ \n//FEdMode\npublic:\nvirtual void Enter() OVERRIDE;\nvirtual void Exit() OVERRIDE;\nÂ \n//More fundamental than DrawHUD\nvirtual void Render(const FSceneView* View,FViewport* Viewport,FPrimitiveDrawInterface* PDI) OVERRIDE;\nÂ \nvirtual void DrawHUD(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,const FSceneView* View,FCanvas* Canvas) OVERRIDE;\nvirtual bool InputKey(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,EKey Key,EInputEvent Event) OVERRIDE;\nvirtual bool MouseMove(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,int32 x, int32 y) OVERRIDE;\nvirtual bool InputAxis(FLevelEditorViewportClient* InViewportClient,FViewport* Viewport,int32 ControllerId,EKey Key,float Delta,float DeltaTime) OVERRIDE;\n/** Notifies all active modes of any change in mouse movement */\nvirtual bool InputDelta( FLevelEditorViewportClient* InViewportClient,FViewport* InViewport,FVector& InDrag,FRotator& InRot,FVector& InScale ) OVERRIDE;\nÂ \nvirtual bool HandleClick(FLevelEditorViewportClient* InViewportClient, HHitProxy *HitProxy, const FViewportClick &Click) OVERRIDE;\nvirtual void Tick(FLevelEditorViewportClient* ViewportClient,float DeltaTime) OVERRIDE;\nÂ \n//Cursor\nvirtual bool GetCursor(EMouseCursor::Type& OutCursor) const OVERRIDE;\nÂ \n/**\n* Lets the mode determine if it wants to draw the widget or not.\n*/\nvirtual bool ShouldDrawWidget() const;\n};')]),e._v(" "),n("h4",{attrs:{id:"cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cpp-2"}},[e._v("#")]),e._v(" .CPP")]),e._v(" "),n("p",[e._v('// Victory Ed Mode extension by Rama\nÂ \n// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\nÂ \n//Victory Alignment Mode\nÂ \n//#include "VictoryGame.h"\n#include "VictoryBPLibraryPrivatePCH.h"\nÂ \n//~~~~~~~~~~~~~~~~\nÂ \n#define CHECK_VSELECTED if(!VictoryEngine) return; if(!VictoryEngine->VSelectedActor) return;\nÂ \n//~~~ Display Choices ~~~\n#define VERTEX_DISPLAY_STARS \t\t0\n#define VERTEX_DISPLAY_3DBOX \t\t1\n#define VERTEX_DISPLAY_RECT \t\t\t2\n#define VERTEX_DISPLAY_DIAMOND3D \t3\n#define VERTEX_DISPLAY_SPHERE \t\t4\n#define VERTEX_SELECTED_MULT\t\t1.333\n#define VERTEX_SHAPE_MULT\t\t\t0.8\n//~~~ Defines ~~~\nÂ \n//MAX\n#define MAX_VERTEX_COUNT_FOR_DRAWING 10000\n#define MAX_VERTEX_COUNT_FOR_DRAWING_SPHERES 5000\nÂ \n//Speeds\n#define XYZSPEEDMULT 20\nÂ \n//3D\n#define DEFAULT_INSTANT_MOVE_DISTANCE 2048\n#define CURSOR_DELTA_DISTANCE_CALC 2048\n//HUD\n#define VICTORY_TITLE_HEIGHT 38\n#define VICTORY_TEXT_HEIGHT 24\nÂ \n//Color\n#define RED \t\t0\n#define BLUE\t\t1\n#define YELLOW 3\nÂ \n//TIME\n#define VICTORY_TITLE_VISIBLE_DURATION 2\nÂ \n//Button Vibes\n#define BUTTON_VIBE_VICTORYHOTKEYS \t\t0\nÂ \n//~~~ Const ~~~\nconst FLinearColor FVictoryEdAlignMode::RV_Red = FLinearColor(1,0,0,1);\nconst FLinearColor FVictoryEdAlignMode::RV_Yellow = FLinearColor(1,1,0,1);\nconst FLinearColor FVictoryEdAlignMode::RV_Blue= FLinearColor(0,0,1,1);\nconst FColor FVictoryEdAlignMode::RV_VRed = FColor(255,0,0,255);\nconst FColor FVictoryEdAlignMode::RV_VBlue = FColor(0,0,255,255);\nconst FColor FVictoryEdAlignMode::RV_VYellow = FColor(255,255,0,255);\nÂ \nÂ \nFVictoryEdAlignMode::FVictoryEdAlignMode()\n{\nÂ \n}\nFVictoryEdAlignMode::~FVictoryEdAlignMode()\n{\t\n}\nÂ \n//INIT\nvoid FVictoryEdAlignMode::JoyInit(UVictoryEdEngine* EnginePtr)\n{\nID = FName("VictoryEditorMode");\nÂ \n//VictoryEngine\nVictoryEngine = EnginePtr;\nÂ \n//Victory Buttons\nRefreshVictoryButtons();\nÂ \n//Enable Realtime\nReEntering = true;\nÂ \n//Verticies\nDoDrawVerticies = true;\nVertexDisplayChoice = VERTEX_DISPLAY_STARS;\nÂ \n//~~~\nÂ \nUsingMouseInstantMove = false;\nCurrentVerticiesScale = 12;\nÂ \n//~~~\nÂ \n//Traces\nRV_TraceParams = FCollisionQueryParams(FName(TEXT("HUDRMBDown")), true, NULL);\nRV_TraceParams.bTraceComplex = true;\n//RV_TraceParams.bTraceAsyncScene = true;\nRV_TraceParams.bReturnPhysicalMaterial = false;\n}\nÂ \nvoid FVictoryEdAlignMode::RefreshVictoryButtons()\n{\nVictoryButtons.Empty();\n//~~~~~~~~~~~~\nÂ \nFVButton NewButton;\nNewButton.Vibe \t= BUTTON_VIBE_VICTORYHOTKEYS;\nNewButton.minX\t=\t10;\nNewButton.maxX\t=\t200;\nNewButton.minY\t=\tVICTORY_TITLE_HEIGHT;\nNewButton.maxY\t=\tVICTORY_TITLE_HEIGHT + VICTORY_TEXT_HEIGHT;\nVictoryButtons.Add(NewButton);\n}\nÂ \n//EXIT\nvoid FVictoryEdAlignMode::Exit()\n{\nUsingMouseInstantMove = false;\n}\n//ENTER\nvoid FVictoryEdAlignMode::Enter()\n{\n//FEdMode::Enter();\n//~~~~~~~~\nÂ \n//Victory Title Appears\nVictoryTitleAppears();\nReEntering = true;\nÂ \n//Clear keys\nMinusIsDown = false;\nPlusIsDown = false;\nShiftDown = false;\nÂ \n//Trace\nRV_TraceParams = FCollisionQueryParams(FName(TEXT("HUDRMBDown")), true, NULL);\nÂ \n//~~~~~~~~~~~~~~~~\nÂ \n//testing\nCHECK_VSELECTED\nÂ \n//CreateUModel();\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \nFDropToClosestSurfaceData* FVictoryEdAlignMode::GetActorWithShortestDrop(TArray<FDropToClosestSurfaceData>& TheData)\n{\n//No Actors\nif(TheData.Num() < 1) return NULL;\nÂ \n//Only 1 Actor\nif(TheData.Num() < 2) return &TheData[0];\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \nfloat SmallestDistance = 100000000;\nint32 SmallestDataIndex = 0;\nÂ \n//Find Smallest\nfor(int32 b = 0; b < TheData.Num(); b++)\n{\nif( TheData[b].DistSquared < SmallestDistance)\n{\nSmallestDistance = TheData[b].DistSquared;\nSmallestDataIndex = b;\n}\n}\nÂ \n//Valid?\nif(TheData.IsValidIndex(SmallestDataIndex))\n{\nreturn &TheData[SmallestDataIndex];\n}\nÂ \nreturn NULL;\n}\nvoid FVictoryEdAlignMode::DropSelectedActorsToNearestSurface()\n{\nif(!VictoryEngine) return;\n//~~~~~~~~~~~~~\nÂ \nÂ \n//ONLY WORKING WITH SMAs at the moment, due to nature of rest of plugin\nAStaticMeshActor* AsSMA = NULL;\nÂ \n//~~~~~~~~~~~~~~\n// Closest Surface Data\n//~~~~~~~~~~~~~~\nTArray<FDropToClosestSurfaceData> ClosestSurfaceData;\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//TRACE PARAMETERS\nFCollisionQueryParams TraceParams(FName(TEXT("VictoryEd Trace")), true, NULL);\nTraceParams.bTraceComplex = true;\n//TraceParams.bTraceAsyncScene = true;\nTraceParams.bReturnPhysicalMaterial = false;\nÂ \n//Ignore  ALL Selected Actors\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nVSelectItrActor = Cast<AActor>(*VSelectItr);\nif(!VSelectItrActor) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \n//Add\nTraceParams.AddIgnoredActor(VSelectItrActor);\n}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//~~~~~~~~~~~\n//Hit Result\nFHitResult TheHit;\n//~~~~~~~~~~~\nÂ \nÂ \n//Iterate Over Selected Actors\nFVector ActorLoc;\nFVector BottomPoint;\nFVector OffsetFromCenter;\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nAsSMA = Cast<AStaticMeshActor>(*VSelectItr);\nif(!AsSMA) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \n//~~~~~~~~~~~~~~~\n//~~~ Do the Trace ~~~\n//~~~~~~~~~~~~~~~\nÂ \n//Re-initialize hit info\nTheHit = FHitResult(ForceInit);\nÂ \n//Trace!\nActorLoc = AsSMA->GetActorLocation();\nGetWorld()->LineTraceSingle(\nTheHit,\t\t//result\nActorLoc,\t\t\t\t\t\t\t\t\nActorLoc + FVector(0,0,-20000),\nECC_Pawn, //collision channel\nTraceParams\n);\nÂ \n//Hit any Actor?\nif(!TheHit.GetActor()) continue;\n//~~~~~~~~~~~~~~~~~\nÂ \nÂ \n//See .h\nGetBottomSurfacePoint(AsSMA,BottomPoint);\nÂ \nÂ \n//Offset From Center\nOffsetFromCenter = ActorLoc - BottomPoint;\nÂ \n//~~~ ADD Closest Surface Data ~~~\nFDropToClosestSurfaceData NewData;\nNewData.TheActor = AsSMA;\nNewData.SurfaceLoc = TheHit.ImpactPoint + OffsetFromCenter;\nNewData.DistSquared = FVector::DistSquared(AsSMA->GetActorLocation(),NewData.SurfaceLoc);\nClosestSurfaceData.Add(NewData);\nÂ \n}\nÂ \nÂ \n//Get Smallest Drop Data\nFDropToClosestSurfaceData* SmallestDropData = GetActorWithShortestDrop(ClosestSurfaceData);\nif(!SmallestDropData) return;\n//~~~~~~~~~~~~~~~\nÂ \n//Get Smallest Drop Actor\nAStaticMeshActor* AnchorActor = SmallestDropData->TheActor;\nif(!AnchorActor) return;\n//~~~~~~~~~~~~~~~\nÂ \nÂ \nÂ \n//Get Relative Offsets of this to all other actors in selection\nconst FVector Origin = AnchorActor->GetActorLocation();\nTArray<FVector> AnchorOffsets;\nAActor* AsActor;\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nAsActor = Cast<AActor>(*VSelectItr);\nif(!AsActor) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \nAnchorOffsets.Add(AsActor->GetActorLocation() - Origin);\n}\nÂ \nÂ \n//~~~ Move Anchor Actor ~~~\nÂ \n//Move to impact, Plus the offset from nearest surface of object\nAnchorActor->SetActorLocation(SmallestDropData->SurfaceLoc);\nÂ \n//Move all other actors to Anchor Actor + Offset\nint32 AnchorItr = 0;\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nAsActor = Cast<AActor>(*VSelectItr);\nif(!AsActor) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \n//VALID?\nif(!AnchorOffsets.IsValidIndex(AnchorItr)) break;\nÂ \nAsActor->SetActorLocation(SmallestDropData->SurfaceLoc + AnchorOffsets[AnchorItr]);\nÂ \n//INC\nAnchorItr++;\n}\nÂ \nÂ \n//~~~~~~~~~~~~~~\nÂ \n//Update Display!\nDoSingleDisplayUpdate = true;\nÂ \nÂ \n//~~~ RESELECT SINGLE ACTOR TO MOVE WIDGET\nif(VictoryEngine->GetSelectedActorCount() < 2)\n{\n//~~~~~~~~~~~~~~~~~\n//Deselect without Noting\nVictoryEngine->SelectNone(false, true, false);\nVictoryEngine->SelectActor(AnchorActor,true,true);\n}\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \nFPositionVertexBuffer* FVictoryEdAlignMode::GetVerticies(AStaticMeshActor* TheSMA)\n{\nif(!TheSMA) return NULL;\nif(!TheSMA->IsValidLowLevel()) return NULL;\nif(!TheSMA->StaticMeshComponent) return NULL;\nif(!TheSMA->StaticMeshComponent->StaticMesh) return NULL;\nif(!TheSMA->StaticMeshComponent->StaticMesh->RenderData) return NULL;\nÂ \n//Valid LODÂ ?\nif(TheSMA->StaticMeshComponent->StaticMesh->RenderData->LODResources.Num() <= 0) return NULL;\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\tVertex Buffer Check\nFPositionVertexBuffer* VertexBuffer =\n&TheSMA->StaticMeshComponent->StaticMesh->RenderData->LODResources[0].PositionVertexBuffer;\nÂ \n//~~~~~~~~~~~~~~~~~~~~\n//\t\t\tCount Too High?\nif(VertexBuffer->GetNumVertices() > MAX_VERTEX_COUNT_FOR_DRAWING)\n{\n//UE_LOG(Victory, Error, TEXT("Vertex Count too high to draw!Â %d"), VertexBuffer->GetNumVertices() );\nreturn NULL;\n//~~~~~~~\n}\nÂ \n//Return Vertex Buffer\nreturn &TheSMA->StaticMeshComponent->StaticMesh->RenderData->LODResources[0].PositionVertexBuffer;\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n/*\nUENUM()\nenum EInputEvent\n{\nIE_Pressed              =0,\nIE_Released             =1,\nIE_Repeat               =2,\nIE_DoubleClick          =3,\nIE_Axis                 =4,\nIE_MAX                  =5,\n};\n*/\nÂ \n//Pressed\nvoid FVictoryEdAlignMode::InputKeyPressed(EKey Key)\n{\n//UE_LOG(Victory, Error, TEXT("Key pressedÂ %s"), *EKeys::GetKeyName(Key).ToString() );\nÂ \nif(!VictoryEngine) return;\n//~~~~~~~~~~~~\nÂ \n//RMB\nif(Key == EKeys::RightMouseButton)\n{\nRMBDown = true;\nreturn;\n//~~~~~~\n}\nÂ \n//Left Mouse\nif(Key == EKey::LeftMouseButton)\n{\nLeftMouseClick();\nreturn;\n//~~~~~~\n}\nÂ \n//X Key\nif(Key == EKey::X)\n{\nXDown = true;\nreturn;\n}\nÂ \n//Y Key\nif(Key == EKey::Y)\n{\nDropSelectedActorsToNearestSurface();\nreturn;\n}\nÂ \n//U Key\nif(Key == EKey::U)\n{\nYDown = true;\nDoDrawVerticies = !DoDrawVerticies;\nreturn;\n}\nÂ \n//K Key\nif(Key == EKey::K)\n{\nif(VictoryEngine->VSelectedActor)\nVictoryEngine->VSelectedActor->SetActorRotation(FRotator::ZeroRotator);\nreturn;\n}\nÂ \n//SHIFT KEY\nif(Key == EKey::LeftShift || Key == EKey::RightShift)\n{\nShiftDown = true;\nreturn;\n}\nÂ \nÂ \n//- Key\nif(Key == EKeys::Underscore)\n{\nMinusIsDown = true;\nPendingButtonRefresh = true;\nreturn;\n}\n//+ Key\nif(Key == EKey::Equals)\n{\nPlusIsDown = true;\nPendingButtonRefresh = true;\nreturn;\n}\nÂ \n//T Key\nif(Key == EKey::T)\n{\nUsingMouseInstantMove = !UsingMouseInstantMove;\nreturn;\n//~~~~~~~~~\n}\nÂ \n//V Key\nif(Key == EKey::V)\n{\nSnapKeyPressed = true;\nreturn;\n//~~~~~~~~~\n}\n//B Key\nif(Key == EKey::B)\n{\nVertexDisplayChoice++;\nif(VertexDisplayChoice > 4) VertexDisplayChoice = 0;\nreturn;\n//~~~~~~~~~\n}\nÂ \nÂ \n//Restore Previous Editor Mode\nif(Key == EKey:ðŸ˜›)\n{\n//Clear all Verticies\nÂ \n//Exit\nVictoryEngine->ExitVictoryAlignMode();\nÂ \nreturn;\n//~~~~~~\n}\n}\nÂ \n//Released\nvoid FVictoryEdAlignMode::InputKeyReleased(EKey Key)\n{\n//RMB\nif(Key == EKeys::RightMouseButton)\n{\nPendingButtonRefresh = true;\nRMBDown = false;\n}\nÂ \n//LMB\nelse if(Key == EKeys::LeftMouseButton)\n{\nPendingButtonRefresh = true;\n}\nÂ \n//SHIFT KEY\nif(Key == EKey::LeftShift || Key == EKey::RightShift) ShiftDown = false;\nÂ \n//- Key\nelse if(Key == EKeys::Underscore) MinusIsDown = false;\nÂ \n//+ Key\nelse if(Key == EKey::Equals)  PlusIsDown = false;\nÂ \n//X Key\nelse if(Key == EKey::X) XDown = false;\nÂ \n//Y Key\nelse if(Key == EKey::Y) YDown = false;\nÂ \n}\nÂ \n//Double Click\nvoid FVictoryEdAlignMode::InputKeyDoubleClick(EKey Key)\n{\n//UE_LOG(Victory, Error, TEXT("Key DOUBLE CLICKÂ %s"), *EKeys::GetKeyName(Key).ToString() );\n}\nÂ \nbool FVictoryEdAlignMode::InputKey(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,EKey Key,EInputEvent Event)\n{\n//Middle Mouse\nif (Key == EKeys::MiddleMouseButton) \t\t\tMiddleMouseEvent(Event);\nelse if(Event == EInputEvent::IE_Pressed) \t\tInputKeyPressed(Key);\nelse if(Event == EInputEvent::IE_Released) \tInputKeyReleased(Key);\nelse if(Event == EInputEvent::IE_DoubleClick) \tInputKeyDoubleClick(Key);\nÂ \nreturn false;\n}\nÂ \nvoid FVictoryEdAlignMode::ProcessMouseInstantMove(FLevelEditorViewportClient* ViewportClient)\n{\nCHECK_VSELECTED\nif(!ViewportClient) return;\n//~~~~~~~~~~~~~~~\nÂ \n//Re-initialize hit info\nRV_Hit = FHitResult(ForceInit);\nÂ \n//Clear Previous Ignore Actors\nRV_TraceParams.IgnoreActors.Empty();\nÂ \n//Ignore All Selected Actors!!!\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nVSelectItrActor = Cast<AActor>(*VSelectItr);\nif(!VSelectItrActor) continue;\n//~~~~~~~~~~~~~~~~~~\nÂ \n//Add\nRV_TraceParams.AddIgnoredActor(VSelectItrActor);\n}\nÂ \n//Trace\nGetWorld()->LineTraceSingle(\nRV_Hit,\t\t//result\nCursorWorldPos,\t//start\nCursorWorldPos + 100000 * CursorWorldDir , //end\nECC_WorldStatic, //collision channel\nRV_TraceParams\n);\nÂ \n//Store Hit Actor\nRV_HitActor = RV_Hit.GetActor();\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\tUpdate Highlighted Actor\nÂ \n//does  not equal same\t\t  does not equal the main Selected Actor\nif(RV_HitActor != HighlightedActor && RV_HitActor != VictoryEngine->VSelectedActor )\n{\n//potentially deselect any highlighted\nHighlightedActor = Cast<AStaticMeshActor>(RV_HitActor);\nÂ \n//Refresh Vertex Buffer\nHighlightedVertexBuffer = NULL;\nif(HighlightedActor) HighlightedVertexBuffer = GetVerticies(HighlightedActor);\nÂ \nÂ \n}\nÂ \nif(RV_Hit.bBlockingHit)\n{\n//INVALIDATE THE DISPLAY\nViewportClient->Viewport->InvalidateDisplay();\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tPROCESS MOUSE INSTANT MOVE?\nif(!UsingMouseInstantMove) return;\n//~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \n//If not hit something, use default distance\nif(!RV_Hit.bBlockingHit) RV_Hit.ImpactPoint = CursorWorldPos + DEFAULT_INSTANT_MOVE_DISTANCE * CursorWorldDir;\nÂ \nÂ \n//\t\tMove the Primary, the Origin!\nRV_Vect = RV_Hit.ImpactPoint;\nÂ \n//Use Existing Z of Object\nRV_Vect.Z = VictoryEngine->VSelectedActor->GetActorLocation().Z;\nÂ \n//Update Location\nVictoryEngine->VSelectedActor->SetActorLocation(RV_Vect);\t\nÂ \n//Save New Origin Location\nconst FVector NewOrigin(RV_Vect);\nÂ \n//~~~~~~~\nÂ \n//Update the Others According to the Moved Origin\nRV_Int32 = 0;\nfor(FSelectionIterator VSelectItr = VictoryEngine->GetSelectedActorIterator();\nVSelectItr; ++VSelectItr )\n{\nVSelectItrActor = Cast<AActor>(*VSelectItr);\nif(!VSelectItrActor)\n{\nRV_Int32++;\ncontinue;\n}\n//~~~~~~~~~~~~~~~~~~\nÂ \n//Get New Origin\nRV_Vect = NewOrigin;\nÂ \n//Add Offset\nif(VictoryEngine->SelectionRelativeOffsets.IsValidIndex(RV_Int32))\n{\nRV_Vect+=VictoryEngine->SelectionRelativeOffsets[RV_Int32];\n}\nÂ \n//Update Location\nVSelectItrActor->SetActorLocation(RV_Vect);\nÂ \n//Inc\nRV_Int32++;\n}\nÂ \n//INVALIDATE THE DISPLAY\nViewportClient->Viewport->InvalidateDisplay();\nÂ \n}\nÂ \nbool FVictoryEdAlignMode::InputDelta( FLevelEditorViewportClient* InViewportClient,FViewport* InViewport,FVector& InDrag,FRotator& InRot,FVector& InScale )\n{\n//only works if LMB is down\nÂ \nreturn false;\n}\nÂ \nbool FVictoryEdAlignMode::InputAxis(FLevelEditorViewportClient* InViewportClient,FViewport* Viewport,int32 ControllerId,EKey Key,float Delta,float DeltaTime)\n{\n//only works if any mouse button is down\nÂ \nreturn false;\n}\nÂ \nbool FVictoryEdAlignMode::MouseMove(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,int32 x, int32 y)\n{\nif(!ViewportClient) return false;\nÂ \n//~~~~~~~~~~~~~~~\n//\tESSENTIAL UPDATES\nMouseLocation.X=x;\nMouseLocation.Y=y;\nÂ \n//~~~ Cursor World Space ~~~\nFViewportCursorLocation CursorWS = ViewportClient->GetCursorWorldLocationFromMousePos();\nCursorWorldPos = CursorWS.GetOrigin();\nCursorWorldDir = CursorWS.GetDirection();\nÂ \n//Calc Delta\nRV_Vect = CursorWorldPos + CursorWorldDir * CURSOR_DELTA_DISTANCE_CALC;\nCursorWorldDelta = RV_Vect - CursorWorldPrevPos;\nCursorWorldDelta /= 4;\nif(CursorWorldDelta.SizeSquared() < 3) CursorWorldDelta = FVector::ZeroVector;\nif(CursorWorldDelta.SizeSquared() > 10000) CursorWorldDelta = FVector::ZeroVector;\nÂ \n//Save Prev\nCursorWorldPrevPos = RV_Vect;\nÂ \n//~~~~~~~~~~~~~~~\nÂ \n//SUPER HYPER BUTTON REFRESHING\n//\t\tdue to the slide physx camera thing when moving\nif(!UsingMouseInstantMove) PendingButtonRefresh = true;\nÂ \nreturn false;\n}\nÂ \n//Middle Mouse Event\nvoid FVictoryEdAlignMode::MiddleMouseEvent(EInputEvent Event)\n{\n//Pressed\nif(Event == EInputEvent::IE_Pressed)\n{\nÂ \nÂ \nreturn;\n}\nÂ \n//Released\nif(Event == EInputEvent::IE_Released)\n{\nÂ \nreturn;\n}\n}\nÂ \n//Left Mouse Click\nvoid FVictoryEdAlignMode::LeftMouseClick()\n{\nCHECK_VSELECTED\nÂ \n//SelectedVertexForSelectedActor = -1;\n}\nbool FVictoryEdAlignMode::HandleClick(FLevelEditorViewportClient* InViewportClient, HHitProxy *HitProxy, const FViewportClick &Click)\n{\nÂ \nreturn false;\n}\nÂ \n//~~~\nÂ \n//``\nvoid FVictoryEdAlignMode::GetSelectedVertexLocation(FVector& LocOut)\n{\nCHECK_VSELECTED\nÂ \nif(!SelectedVertexBuffer)  return;\t\n//~~~~~~~~~~~~~~~~~~\nÂ \nconst FTransform SMATransform = VictoryEngine->VSelectedActor->GetTransform();\nconst FVector SMALocation \t\t= SMATransform.GetLocation();\nconst int32 VertexCount \t\t\t= SelectedVertexBuffer->GetNumVertices();\nfor(int32 Itr = 0; Itr < VertexCount; Itr++)\n{\nif(Itr == SelectedVertexForSelectedActor)\n{\nLocOut = SMALocation + SMATransform.TransformVector(SelectedVertexBuffer->VertexPosition(Itr));\nreturn;\n//~~~~\n}\n}\n}\nÂ \nvoid FVictoryEdAlignMode::DoVertexSnap(const FVector& Dest)\n{\nCHECK_VSELECTED\nÂ \nFVector SelectedVertexLocation;\nÂ \n//Initial Location\nGetSelectedVertexLocation(SelectedVertexLocation);\nÂ \n//Match rotation of owner of target vertex?\nif(ShiftDown)\n{\nVictoryEngine->VSelectedActor->SetActorRotation(RV_Hit.ImpactNormal.Rotation());\n//Recalc Selected Vertex After Rotation\nGetSelectedVertexLocation(SelectedVertexLocation);\nÂ \n//UE_LOG(Victory, Error, TEXT("WHAT IS HIT NORMALÂ %s"), *RV_Hit.ImpactNormal.Rotation().ToString() );\n}\nÂ \n//No modifier, just regular click\nÂ \n//1. calc distance between selected vertex and JSMA location\n//2. move the JSMA to the target vertex\n//3. subtract the distance\nÂ \n//Distance Offset\nconst FVector LocOffset = SelectedVertexLocation - VictoryEngine->VSelectedActor->GetActorLocation();\nÂ \n//Set Location\nVictoryEngine->VSelectedActor->SetActorLocation(Dest - LocOffset);\nÂ \n//Refresh After Moving\nPendingButtonRefresh = true;\n}\nÂ \nvoid FVictoryEdAlignMode::RefreshVertexButtons(const FSceneView* View)\n{\nCHECK_VSELECTED\nÂ \nif(!View) return;\n//~~~~~~~~~~~~~\nÂ \n//No Longer Pending\nPendingButtonRefresh = false;\nÂ \n//Refresh\nSelectedActorButtons.Empty();\nHighlightedActorButtons.Empty();\nÂ \n//~~~ Vars ~~~\nconst float ButtonHalfSize = CurrentVerticiesScale/2;\nÂ \n//~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tSelected Actor\n//~~~~~~~~~~~~~~~~~~~~~\nif(!VictoryEngine->VSelectedActor->IsValidLowLevel() ) return;\nÂ \nif(!SelectedVertexBuffer)  return;\t\n//~~~~~~~~~~~~~~~~~~\nÂ \nFTransform SMATransform = VictoryEngine->VSelectedActor->GetTransform();\nFVector SMALocation \t\t= SMATransform.GetLocation();\nconst int32 VertexCount \t\t\t= SelectedVertexBuffer->GetNumVertices();\nfor(int32 Itr = 0; Itr < VertexCount; Itr++)\n{\n//Get Rotated Scaled Translated Vertex Pos\nVertexWorldSpace = SMALocation + SMATransform.TransformVector(SelectedVertexBuffer->VertexPosition(Itr));\nÂ \n//Get 2D Center\nVictoryProject(View,\nVertexWorldSpace,\nVertex2DCenter\n);\nÂ \nFVButton NewButton;\nNewButton.Vibe \t\t\t= \tItr;\nNewButton.PointInWorld \t= \tVertexWorldSpace;\nNewButton.minX\t\t\t=\tVertex2DCenter.X - ButtonHalfSize;\nNewButton.maxX\t\t\t=\tVertex2DCenter.X + ButtonHalfSize;\nNewButton.minY\t\t\t=\tVertex2DCenter.Y - ButtonHalfSize;\nNewButton.maxY\t\t\t=\tVertex2DCenter.Y + ButtonHalfSize;\nÂ \n//Add Button\nSelectedActorButtons.Add(NewButton);\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tHighlighted Actor\n//~~~~~~~~~~~~~~~~~~~~~\nif(!HighlightedActor) return;\nif(!HighlightedActor->IsValidLowLevel()) return;\nÂ \nif(!HighlightedVertexBuffer)  return;\t\n//~~~~~~~~~~~~~~~~~~\nÂ \nSMATransform = HighlightedActor->GetTransform();\nSMALocation \t\t= SMATransform.GetLocation();\nconst int32 VertexCount2 \t\t\t= HighlightedVertexBuffer->GetNumVertices();\nfor(int32 Itr = 0; Itr < VertexCount2; Itr++)\n{\n//Get Rotated Scaled Translated Vertex Pos\nVertexWorldSpace = SMALocation + SMATransform.TransformVector(HighlightedVertexBuffer->VertexPosition(Itr));\nÂ \n//Get 2D Center\nVictoryProject(View,\nVertexWorldSpace,\nVertex2DCenter\n);\nÂ \nFVButton NewButton;\nNewButton.Vibe \t\t\t= \tItr;\nNewButton.PointInWorld \t= \tVertexWorldSpace;\nNewButton.minX\t\t\t=\tVertex2DCenter.X - ButtonHalfSize;\nNewButton.maxX\t\t\t=\tVertex2DCenter.X + ButtonHalfSize;\nNewButton.minY\t\t\t=\tVertex2DCenter.Y - ButtonHalfSize;\nNewButton.maxY\t\t\t=\tVertex2DCenter.Y + ButtonHalfSize;\nÂ \n//Add Button\nHighlightedActorButtons.Add(NewButton);\n}\nÂ \n}\nÂ \n//```\nvoid FVictoryEdAlignMode::PDI_DrawVerticies(const FSceneView* View, FPrimitiveDrawInterface* PDI, const FPositionVertexBuffer* VertexBuffer, const FTransform& SMATransform, bool DrawingSelectedActor)\n{\nCHECK_VSELECTED\nÂ \nif(!View) \t\t\treturn;\nif(!PDI) \t\t\treturn;\nif(!VertexBuffer) \treturn;\n//~~~~~~~~~~~~~~~\nÂ \n//Location\nconst FVector SMALocation \t\t\t= SMATransform.GetLocation();\nÂ \n//Get Count\nconst int32 VertexCount = VertexBuffer->GetNumVertices();\nÂ \n//~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tSelected Actor\n//~~~~~~~~~~~~~~~~~~~~~\nif(DrawingSelectedActor)\n{\nfor(int32 Itr = 0; Itr < VertexCount; Itr++)\n{\n//Selected Vertex?\nif(SelectedVertexForSelectedActor == Itr )\n{\n//Draw to the PDI\nPDI->DrawPoint(\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_Yellow,\nCurrentVerticiesScale*VERTEX_SELECTED_MULT,\n0 //depth\n);\ncontinue;\n}\nelse if(HighlightedVertexForSelectedActor == Itr)\n{\n//Draw to the PDI\nPDI->DrawPoint(\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nFLinearColor(0,1,1,1),\nCurrentVerticiesScale*VERTEX_SELECTED_MULT,\n0 //depth\n);\ncontinue;\n}\nelse\n{\nÂ \n//Spheres\nif(VertexDisplayChoice == VERTEX_DISPLAY_SPHERE)\n{\nif(VertexCount > MAX_VERTEX_COUNT_FOR_DRAWING_SPHERES)\n{\nDrawWireBox(\nPDI,\nBoxFromPointWithSize(SMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),CurrentVerticiesScale*0.5),\nRV_VRed,\n0\n);\ncontinue;\n}\nelse\n{\nDrawWireSphere(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_VRed,\nCurrentVerticiesScale*VERTEX_SHAPE_MULT,\n12,\n0\n);\ncontinue;\n}\n}\nÂ \n//Diamond\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_DIAMOND3D)\n{\nDrawWireSphere(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_VRed,\nCurrentVerticiesScale*VERTEX_SHAPE_MULT,\n4,\n0\n);\ncontinue;\n}\nÂ \n//Box\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_3DBOX)\n{\nDrawWireBox(\nPDI,\nBoxFromPointWithSize(SMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),CurrentVerticiesScale*VERTEX_SHAPE_MULT),\nRV_VRed,\n0\n);\ncontinue;\n}\nÂ \n//Stars\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_STARS)\n{\nDrawWireStar(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nCurrentVerticiesScale,\nRV_VRed,\n0\n);\ncontinue;\n}\nÂ \n//Rect\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_RECT)\n{\n//Draw to the PDI\nPDI->DrawPoint(\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_Red,\nCurrentVerticiesScale,\n0 //depth\n);\ncontinue;\n}\nÂ \n}\nÂ \n}\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tHighlighted Actor\n//~~~~~~~~~~~~~~~~~~~~~\nelse\n{\nfor(int32 Itr = 0; Itr < VertexCount; Itr++)\n{\nif(HighlightedVertexForHighlightedActor == Itr)\n{\n//Draw to the PDI\nPDI->DrawPoint(\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nFLinearColor(0,1,1,1),\nCurrentVerticiesScale*VERTEX_SELECTED_MULT,\n0 //depth\n);\ncontinue;\n}\nÂ \n//Spheres\nif(VertexDisplayChoice == VERTEX_DISPLAY_SPHERE)\n{\nif(VertexCount > MAX_VERTEX_COUNT_FOR_DRAWING_SPHERES)\n{\nDrawWireBox(\nPDI,\nBoxFromPointWithSize(SMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),CurrentVerticiesScale*VERTEX_SHAPE_MULT),\nRV_VBlue,\n0\n);\ncontinue;\n}\nelse\n{\nDrawWireSphere(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_VBlue,\nCurrentVerticiesScale*VERTEX_SHAPE_MULT,\n12,\n0\n);\ncontinue;\n}\n}\nÂ \n//Diamond\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_DIAMOND3D)\n{\nDrawWireSphere(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_VBlue,\nCurrentVerticiesScale*VERTEX_SHAPE_MULT,\n4,\n0\n);\ncontinue;\n}\nÂ \n//Box\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_3DBOX)\n{\nDrawWireBox(\nPDI,\nBoxFromPointWithSize(SMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),CurrentVerticiesScale),\nRV_VBlue,\n0\n);\ncontinue;\n}\nÂ \n//Stars\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_STARS)\n{\nÂ \nDrawWireStar(\nPDI,\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nCurrentVerticiesScale,\nRV_VBlue,\n0\n);\ncontinue;\n}\nÂ \n//Rect\nelse if(VertexDisplayChoice == VERTEX_DISPLAY_RECT)\n{\n//Draw to the PDI\nPDI->DrawPoint(\nSMALocation + SMATransform.TransformVector(VertexBuffer->VertexPosition(Itr)),\nRV_Blue,\nCurrentVerticiesScale,\n0 //depth\n);\ncontinue;\n}\n}\t\n}\n}\nÂ \nÂ \nvoid FVictoryEdAlignMode::DrawHotkeyToolTip(FCanvas* Canvas)\n{\nif(!Canvas) return;\n//~~~~~~~~~\nÂ \nRV_yStart = MouseLocation.Y + 16;\nÂ \n//Background\nDrawVictoryRect(Canvas,\nMouseLocation.X - 7,\nRV_yStart - 7,\n420,\nVICTORY_TEXT_HEIGHT * 10 + 120,\nFLinearColor(0,0,1,0.777)\n);\nÂ \nDrawVictoryTextWithColor(Canvas,\n"~~~ Victory Editor Mode Hotkeys ~'),n("s",[e._v('",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT * 2;\nDrawVictoryTextWithColor(Canvas,\n"P ~ Restore previous Editor Mode",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 20;\nDrawVictoryTextWithColor(Canvas,\n"Y ~ Drop Objects to Nearest Surface!",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 20;\nDrawVictoryTextWithColor(Canvas,\n"T ~ Toggle Instant Mouse Move Mode",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT;\nDrawVictoryTextWithColor(Canvas,\n"K ~ Reset Rotation",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 20;\nDrawVictoryTextWithColor(Canvas,\n"V ~ Select Verticies for Snapping!",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 5;\nDrawVictoryTextWithColor(Canvas,\n"SHIFT + V ~ Snap by Surface Normal",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 5;\nDrawVictoryTextWithColor(Canvas,\n"B ~ Toggle Different Vertex Types!!!",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 4;\nDrawVictoryTextWithColor(Canvas,\n"Hold + or - ~ Change Vertex Size!",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\nÂ \nRV_yStart += VICTORY_TEXT_HEIGHT + 4;\nDrawVictoryTextWithColor(Canvas,\n"U ~ Toggle Hiding of All Verticies",\nMouseLocation.X,RV_yStart,\nRV_Yellow\n);\n}\nÂ \nvoid FVictoryEdAlignMode::DrawVictoryText(FCanvas* Canvas, const FString& TheStr, float X, float Y, float TheScale )\n{\nif(!Canvas) return;\n//')]),e._v("~~~~~~~\nÂ \nFCanvasTextItem NewText(\nFVector2D(X,Y),\nFText::FromString(TheStr),\nVictoryEngine->GetVictoryFont(),\nFLinearColor(1,0,1,1)\n);\nNewText.Scale.Set(TheScale,TheScale);\nNewText.bOutlined = true;\nNewText.Draw(Canvas);\n}\nvoid FVictoryEdAlignMode::DrawVictoryTextWithColor(FCanvas* Canvas, const FString& TheStr, float X, float Y, FLinearColor TheColor, float TheScale )\n{\nif(!Canvas) return;\n//~~~~~~~~~\nÂ \nFCanvasTextItem NewText(\nFVector2D(X,Y),\nFText::FromString(TheStr),\nVictoryEngine->GetVictoryFont(),\nTheColor\n);\nNewText.Scale.Set(TheScale,TheScale);\nNewText.bOutlined = true;\nÂ \n//Outline gets its alpha from the main color\nNewText.OutlineColor = FLinearColor(0,0,0,TheColor.A * 2);\nÂ \nNewText.Draw(Canvas);\n}\nÂ \nvoid FVictoryEdAlignMode::DrawVictoryLine(\nFCanvas* Canvas,\nconst FVector2D& Start,\nconst FVector2D& End,\nFLinearColor TheColor,\nfloat Thick\n)\n{\nif(!Canvas) return;\n//~~~~~~~~~\nÂ \nFCanvasLineItem NewLine(Start,End);\nNewLine.SetColor(TheColor);\nNewLine.LineThickness = Thick;\nNewLine.Draw(Canvas);\n}\nvoid FVictoryEdAlignMode::DrawVictoryRect(FCanvas* Canvas, float X, float Y, float Width, float Height, FLinearColor Color)\n{\nif(!Canvas) return;\n//~~~~~~~~~\nÂ \nFCanvasTileItem TileItem(\nFVector2D(X, Y),\nFVector2D( Width, Height ),\nColor\n);\nÂ \nTileItem.BlendMode = SE_BLEND_Translucent;\nTileItem.Draw(Canvas);\nÂ \n/*\nCanvas->DrawTile(\nX, Y,\nWidth, Height,\n0, 0, 1, 1,\nColor\n);\n*/\nÂ \n}\nÂ \nint32 FVictoryEdAlignMode::FindClosestOfButtons(TArray<FVButton*> Inbuttons)\n{\nfloat CurDistance;\nfloat MinDistance = 10000000000;\nint32 MinIndex = -1;\nfor(int32 Itr=0; Itr < Inbuttons.Num(); Itr++)\n{\nCurCheckButton = Inbuttons[Itr];\nif(!CurCheckButton) continue;\nÂ \n//world space location stored in the Button itself\nCurDistance = FVector::DistSquared(CurCheckButton->PointInWorld,CursorWorldPos);\nÂ \n//Min Check\nif(CurDistance < MinDistance)\n{\nMinDistance = CurDistance;\nMinIndex = Itr;\n}\n}\nÂ \n//VALIDITY CHECK\nif(!Inbuttons.IsValidIndex(MinIndex))\nreturn -1;\nÂ \nelse return MinIndex;\n}\nÂ \nvoid FVictoryEdAlignMode::CheckCursorInButtons(FCanvas* Canvas)\n{\t\nif(!Canvas) return;\n//~~~~~~~~~\nÂ \n//Reset Highlighted\nHighlightedVertexForSelectedActor = -1;\nHighlightedVertexForHighlightedActor = -1;\nÂ \n//~~~~~~~~~~~~~~~~~~~\n//Main Buttons\n//~~~~~~~~~~~~~~~~~~~\nRV_Int32=0;\nwhile(VictoryButtons.IsValidIndex(RV_Int32))\n{\nCurCheckButton = &VictoryButtons[RV_Int32];\nÂ \n//check cursor in bounds\nif (CurCheckButton->minX <= MouseLocation.X && MouseLocation.X <= CurCheckButton->maxX &&\nCurCheckButton->minY <= MouseLocation.Y && MouseLocation.Y <= CurCheckButton->maxY )\n{\n//Active Button Type\nActiveButton_Vibe = CurCheckButton->Vibe;\nÂ \nif(ActiveButton_Vibe == BUTTON_VIBE_VICTORYHOTKEYS)\n{\nDrawHotkeyToolTip(Canvas);\nFadeInVictoryTitle = true;\nVictoryTitleVisible = false; //prevent a duel between the two\nreturn;\n//~~~~~\n}\n}\nÂ \n//~~~~~~~\nRV_Int32++;\n}\nÂ \n//~~~~~~~~~~~~~~~~~~~\n//Selected Actor Vertex Buttons\n//~~~~~~~~~~~~~~~~~~~\nRV_Int32=0;\nClosestSelectedActorButtons.Empty();\nwhile(SelectedActorButtons.IsValidIndex(RV_Int32))\n{\nCurCheckButton = &SelectedActorButtons[RV_Int32];\n//check cursor in bounds\nif (CurCheckButton->minX <= MouseLocation.X && MouseLocation.X <= CurCheckButton->maxX &&\nCurCheckButton->minY <= MouseLocation.Y && MouseLocation.Y <= CurCheckButton->maxY )\n{\nClosestSelectedActorButtons.Add(&SelectedActorButtons[RV_Int32]);\n}\nÂ \n//~~~~~~~\nRV_Int32++;\n}\nÂ \n//Find closest of potentially highlighted/selected\nÂ \nconst int32 FoundIndex = FindClosestOfButtons(ClosestSelectedActorButtons);\nif(FoundIndex != -1)\n{\nCurCheckButton = ClosestSelectedActorButtons[FoundIndex];\nif(CurCheckButton)\n{\n//Active Button Type\nActiveButton_Vibe = CurCheckButton->Vibe;\nÂ \n//Highlight Vertex if hovered over!\nHighlightedVertexForSelectedActor = ActiveButton_Vibe;\nÂ \n//Vertex Selected and not same?\nif(SnapKeyPressed && SelectedVertexForSelectedActor != ActiveButton_Vibe )\n{\nSnapKeyPressed = false;\nSelectedVertexForSelectedActor = ActiveButton_Vibe;\nreturn;\n//~~~~~\n}\n}\n}\nÂ \nÂ \nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nÂ \nÂ \n//~~~~~~~~~~~~~~~~~~~~~~\n//Highlighted Actor Vertex Buttons\n//~~~~~~~~~~~~~~~~~~~~~~\nÂ \nRV_Int32=0;\nClosestHighlightedActorButtons.Empty();\nwhile(HighlightedActorButtons.IsValidIndex(RV_Int32))\n{\nCurCheckButton = &HighlightedActorButtons[RV_Int32];\n//check cursor in bounds\nif (CurCheckButton->minX <= MouseLocation.X && MouseLocation.X <= CurCheckButton->maxX &&\nCurCheckButton->minY <= MouseLocation.Y && MouseLocation.Y <= CurCheckButton->maxY )\n{\nClosestHighlightedActorButtons.Add(&HighlightedActorButtons[RV_Int32]);\n}\nÂ \n//~~~~~~~\nRV_Int32++;\n}\nÂ \n//Find closest of potentially highlighted/selected\nÂ \nconst int32 FoundIndex2 = FindClosestOfButtons(ClosestHighlightedActorButtons);\nif(FoundIndex2 != -1)\n{\nCurCheckButton = ClosestHighlightedActorButtons[FoundIndex2];\nif(CurCheckButton)\n{\n//Active Button Type\nActiveButton_Vibe = CurCheckButton->Vibe;\nÂ \n//Highlight Vertex if hovered over!\nHighlightedVertexForHighlightedActor = ActiveButton_Vibe;\nÂ \n//Vertex Selected?\nif(SnapKeyPressed)\n{\nSnapKeyPressed = false;\nDoVertexSnap(CurCheckButton->PointInWorld);\n}\n}\n}\n}\nÂ \n//Victory Project\nvoid FVictoryEdAlignMode::VictoryProject(const FSceneView* View,const FVector& WorldPoint,FVector2D& OutPixelLocation)\n{\nif(!View) return;\n//~~~~~~~~~\nÂ \n/** Transforms a point from the view's world-space into pixel coordinates relative to the view's X,Y (left, top). */\nView->WorldToPixel(WorldPoint,OutPixelLocation);\n}\nÂ \n//Victory DeProject\nvoid FVictoryEdAlignMode::VictoryDeProject(const FSceneView* View,const FVector2D& ScreenPoint, FVector& out_WorldOrigin, FVector& out_WorldDirection)\n{\nif(!View) return;\n//~~~~~~~~~\nÂ \n//NEEDS TO BE MADE CONST TO BE ABLE TO USE THIS\n/** transforms 2D screen coordinates into a 3D world-space origin and direction\n* @param ScreenPos - screen coordinates in pixels\n* @param out_WorldOrigin (out) - world-space origin vector\n* @param out_WorldDirection (out) - world-space direction vector\n*/\n//View->DeprojectFVector2D(ScreenPoint, out_WorldOrigin, out_WorldDirection);\nÂ \nÂ \n/** transforms 2D screen coordinates into a 3D world-space origin and direction\n* @param ScreenPos - screen coordinates in pixels\n* @param ViewRect - view rectangle\n* @param InvViewMatrix - inverse view matrix\n* @param InvProjMatrix - inverse projection matrix\n* @param out_WorldOrigin (out) - world-space origin vector\n* @param out_WorldDirection (out) - world-space direction vector\n*/\nFSceneView::DeprojectScreenToWorld(\nScreenPoint,\nView->ViewRect,\nView->InvViewMatrix,\nView->ViewMatrices.GetInvProjMatrix(),\nout_WorldOrigin,\nout_WorldDirection\n);\nÂ \n}\nÂ \nÂ \n//Draw Using the More Fundamental Method, PDI\nvoid FVictoryEdAlignMode::Render(const FSceneView* View,FViewport* Viewport,FPrimitiveDrawInterface* PDI)\n{\n//~~~ Verticies ~~~\nif(DoDrawVerticies)\n{\nÂ \nif(SelectedVertexBuffer && VictoryEngine->VSelectedActor)\n{\nPDI_DrawVerticies(View,\tPDI,\nSelectedVertexBuffer,VictoryEngine->VSelectedActor->GetTransform(),\ntrue\n);\n}\nÂ \n//Dont draw if Highlighted == Selected, drawn already\nif(HighlightedVertexBuffer && HighlightedActor && HighlightedActor != VictoryEngine->VSelectedActor)\n{\nPDI_DrawVerticies( View,\tPDI,\nHighlightedVertexBuffer, HighlightedActor->GetTransform(),\nfalse //Highlighted Actor\n);\n}\nÂ \n} //end of do draw verticies\n//~~~~~~~~~~~~~~~~~~~\n}\nÂ \n//Draw HUD\nvoid FVictoryEdAlignMode::DrawHUD(FLevelEditorViewportClient* ViewportClient,FViewport* Viewport,const FSceneView* View,FCanvas* Canvas)\n{\nif(!Canvas) return;\nif(!VictoryEngine) return;\n//~~~~~~~~~~~\nÂ \n//Title Button\nDrawVictoryTextWithColor(Canvas, \"Victory Editor Hotkeys\", 10,VICTORY_TITLE_HEIGHT, FLinearColor(1,0,1,VictoryTitleAlpha));\nÂ \n//~~~ Cursor ~~~\nif(!UsingMouseInstantMove) CheckCursorInButtons(Canvas);\nÂ \n//~~~ Make Buttons? ~~~\nif(PendingButtonRefresh) RefreshVertexButtons(View);\nÂ \n//~~~~~~~~~~~~~~~~~~~\n//Mouse Coordinates\n//DrawVictoryText(Canvas, MouseLocation.ToString(), 400,50);\nÂ \n//Mouse World Space Dir\n//DrawVictoryText(Canvas, CursorWorldDir.ToString(), 300,50 + VICTORY_TEXT_HEIGHT );\n}\nÂ \nvoid FVictoryEdAlignMode::Tick_VictoryTitle(FLevelEditorViewportClient* ViewportClient)\n{\nCurTimeSpan = FDateTime::Now() - VictoryTitleAppearTime;\nÂ \n//If > then Allowed Visible Duration, start to fade out\nif(CurTimeSpan.GetTotalSeconds() > VICTORY_TITLE_VISIBLE_DURATION)\n{\nif(VictoryTitleAlpha <= 0)\n{\nVictoryTitleVisible = false;\nVictoryTitleAlpha = 0;\nreturn;\n}\nÂ \nVictoryTitleAlpha -= 0.01;\n}\nÂ \n//INVALIDATE THE DISPLAY\nViewportClient->Viewport->InvalidateDisplay();\n}\nvoid FVictoryEdAlignMode::Tick_VictoryTitleFadeIn()\n{\nif(VictoryTitleAlpha >=1)\n{\nVictoryTitleAppears();\nreturn;\n}\nÂ \nVictoryTitleAlpha += 0.01;\n}\nÂ \n//TICK\nvoid FVictoryEdAlignMode::Tick_VictoryInterface(FLevelEditorViewportClient* ViewportClient)\n{\nif(!ViewportClient) return;\n//~~~~~~~~~~~\nÂ \n//Re-activate Real-time each time enter Mode\n/*\nif(ReEntering)\n{\nReEntering = false;\nViewportClient->SetRealtime(true,true);\n}\n*/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\t\t\t\tHUD\nViewportSize = ViewportClient->Viewport->GetSizeXY();\nÂ \n//Victory Title Tick\nif(VictoryTitleVisible) Tick_VictoryTitle(ViewportClient);\nÂ \n//Fading in?\nif(FadeInVictoryTitle)\n{\nTick_VictoryTitleFadeIn();\nViewportClient->Viewport->InvalidateDisplay();\n}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\tMove cursor if RMB is down\n//if(RMBDown) ViewportClient->Viewport->SetMouse(ViewportSize.X/2, ViewportSize.Y/2);\n}\nÂ \nbool FVictoryEdAlignMode::ShouldDrawWidget() const\n{\nif(UsingMouseInstantMove) return false;\nreturn true;\n}\nÂ \nÂ \nbool FVictoryEdAlignMode::GetCursor(EMouseCursor::Type& OutCursor) const\n{\nif(UsingMouseInstantMove)\n{\nOutCursor = EMouseCursor::GrabHand;\nreturn true;\n}\nÂ \nreturn false; //no modified cursor\n}\nÂ \nvoid FVictoryEdAlignMode::Tick(FLevelEditorViewportClient* ViewportClient,float DeltaTime)\n{\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\tSingle Invalidate\nif(DoSingleDisplayUpdate)\n{\nViewportClient->Viewport->InvalidateDisplay();\nDoSingleDisplayUpdate = false;\n}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\tHUD Elements and Input\nTick_VictoryInterface(ViewportClient);\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\tTRACE CURSOR POSITION\nProcessMouseInstantMove(ViewportClient);\nÂ \nÂ \nÂ \n//~~~ Begin Vertex Related ~~~\nCHECK_VSELECTED\nÂ \n//Minus or Plus?\nif(MinusIsDown) CurrentVerticiesScale -= 0.333;\nelse if(PlusIsDown) CurrentVerticiesScale += 0.333;\nif(CurrentVerticiesScale < 2) CurrentVerticiesScale = 2;\nÂ \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\t\t\t\t\tNew Selection Actor?\nif(VictoryEngine->SelectedActorVerticiesNeedsUpdating)\n{\nVictoryEngine->SelectedActorVerticiesNeedsUpdating = false;\nSelectedVertexBuffer = GetVerticies(Cast<AStaticMeshActor>(VictoryEngine->VSelectedActor));\nPendingButtonRefresh = true;\n}\nÂ \nif(VictoryEngine->ClearSelectedVertex)\n{\nVictoryEngine->ClearSelectedVertex = false;\nSelectedVertexForSelectedActor = -1;\n}\n}")]),e._v(" "),n("h2",{attrs:{id:"core-of-making-your-own-editor-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#core-of-making-your-own-editor-mode"}},[e._v("#")]),e._v(" Core of Making Your Own Editor Mode")]),e._v(" "),n("h3",{attrs:{id:"interaction-of-edengine-with-edmode-class"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#interaction-of-edengine-with-edmode-class"}},[e._v("#")]),e._v(" Interaction of EdEngine with EdMode Class")]),e._v(" "),n("p",[e._v("The key interaction between the Editor Mode class and the extended Unreal Engine class is in the Unreal Engine class, where it creates the editor mode instance.")]),e._v(" "),n("p",[e._v("Here is that code:")]),e._v(" "),n("p",[e._v("//Create it if it not exist yet\nif(!CreatedVictoryEdMode)\n{\nTSharedRef<class FVictoryEdAlignMode,ESPMode::Fast> VictoryEdMode = MakeShareable( new FVictoryEdAlignMode() );\nÂ \n//Init VictoryEdMode\nVictoryEdMode->JoyInit(this);\nÂ \n//Register\nGEditorModeTools().RegisterMode(VictoryEdMode);\nÂ \nCreatedVictoryEdMode = true;\n}")]),e._v(" "),n("h3",{attrs:{id:"activating-the-editor-mode-once-created"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#activating-the-editor-mode-once-created"}},[e._v("#")]),e._v(" Activating The Editor Mode, Once Created")]),e._v(" "),n("p",[e._v("Once you've created your own EdMode class instance, you activate your editor mode using:")]),e._v(" "),n("p",[e._v("//Activate Victory Editor Mode\nGEditorModeTools().ActivateMode(VictoryEditorModeID);")]),e._v(" "),n("h3",{attrs:{id:"the-ed-mode-s-unique-id"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-ed-mode-s-unique-id"}},[e._v("#")]),e._v(" The Ed Mode's Unique ID")]),e._v(" "),n("p",[e._v("Note that this is a const FName that I declared here:")]),e._v(" "),n("p",[e._v('const FName UVictoryEdEngine::VictoryEditorModeID = FName("VictoryEditorMode");')]),e._v(" "),n("p",[e._v("And you have to actually give your EdMode its ID in its class constructor. In my case I used my custom JoyInit function")]),e._v(" "),n("p",[e._v('//INIT\nvoid FVictoryEdAlignMode::JoyInit(UVictoryEdEngine* EnginePtr)\n{\nID = FName("VictoryEditorMode");\n}')]),e._v(" "),n("h2",{attrs:{id:"plugin-build-cs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#plugin-build-cs"}},[e._v("#")]),e._v(" Plugin Build.cs")]),e._v(" "),n("p",[e._v('// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\nÂ \nusing UnrealBuildTool;\nÂ \npublic class VictoryBPLibrary : ModuleRules\n{\npublic VictoryBPLibrary(TargetInfo Target)\n{\nPublicDependencyModuleNames.AddRange(\nnew string[] {\n"Core",\n"CoreUObject",\n"Engine",\n"UnrealEd",\n}\n);\n}\n}')]),e._v(" "),n("h2",{attrs:{id:"plugin-download-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#plugin-download-2"}},[e._v("#")]),e._v(" Plugin Download")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:VictoryPlugin.zip",title:"File:VictoryPlugin.zip"}},[e._v("File:VictoryPlugin.zip")])]),e._v(" "),n("p",[e._v("(Please note this file does not contain an executable, just the .dll that UE4 needs for a plugin, that's why the file warning appears)")]),e._v(" "),n("h2",{attrs:{id:"enjoy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#enjoy"}},[e._v("#")]),e._v(" Enjoy!")]),e._v(" "),n("p",[e._v("I hope that providing you with my entire Vertex Snapping C++ Source code helps you to create your own Editor Plugins!")]),e._v(" "),n("p",[e._v("Enjoy!")]),e._v(" "),n("p",[n("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[e._v("Rama")]),e._v(" ("),n("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[e._v("talk")]),e._v(")")]),e._v(" "),n("p",[e._v('Retrieved from "'),n("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Rama%27s_Vertex_Snap_Editor_Plugin&oldid=17829",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Rama%27s_Vertex_Snap_Editor_Plugin&oldid=17829"),n("OutboundLink")],1),e._v('"')]),e._v(" "),n("p",[n("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/Category:Plug-ins",title:"Category:Plug-ins"}},[e._v("Plug-ins")])])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=r.exports}}]);